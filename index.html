<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<title>SYGN1L</title>

<style>
:root{
  --bg0:#020402; --bg1:#010701;
  --text:#CFFFD6; --muted:#7EDB92;
  --accent:#39FF6A; --danger:#FF3B6B; --warn:#FFD34D;
  --border:rgba(57,255,106,.25);
  --radius:16px; --shadow:0 10px 22px rgba(0,0,0,.55);
  --glow:0 0 18px rgba(57,255,106,.25);
}

html{ background:var(--bg0); -webkit-text-size-adjust:100%; }
body{
  margin:0;
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  color:var(--text);
  background:
    radial-gradient(900px 600px at 60% 15%, rgba(57,255,106,.10), transparent 60%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
  overflow-y:auto;
  -webkit-overflow-scrolling:touch;
  touch-action:manipulation;
  padding:14px 12px calc(24px + env(safe-area-inset-bottom));
}

/* CRT vignette */
body::before{
  content:"";
  position:fixed; inset:0;
  pointer-events:none;
  background: radial-gradient(1200px 900px at 50% 50%, rgba(0,0,0,0) 55%, rgba(0,0,0,.65) 100%);
  z-index:0;
}

/* scanlines */
.fx{ position:fixed; inset:0; pointer-events:none; z-index:0; }
.fx.scanlines{
  background:repeating-linear-gradient(
    to bottom,
    rgba(57,255,106,.05),
    rgba(57,255,106,.05) 1px,
    rgba(0,0,0,0) 4px,
    rgba(0,0,0,0) 8px
  );
  opacity:.24;
}

.wrap{
  position:relative; z-index:1;
  max-width:860px; margin:0 auto;
  display:grid; gap:18px;
}

.card{
  border:1px solid var(--border);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  background:linear-gradient(180deg, rgba(6,28,12,.62), rgba(3,14,7,.40));
  overflow:hidden;
  position:relative;
}
.card::after{
  content:"";
  position:absolute; inset:-2px;
  pointer-events:none;
  box-shadow: inset 0 0 0 1px rgba(57,255,106,.08), inset 0 0 22px rgba(57,255,106,.06);
}

.pad{ padding:14px; position:relative; }

h1{ margin:0; letter-spacing:.25em; font-size:18px; }
.subtitle{ margin-top:6px; font-size:12px; color:var(--muted); letter-spacing:.06em; }

.stats{
  margin-top:12px;
  display:grid; grid-template-columns:1fr;
  gap:10px;
}
@media(min-width:420px){ .stats{ grid-template-columns:repeat(4,1fr); } }

.stat{
  border:1px solid rgba(57,255,106,.2);
  border-radius:12px;
  padding:10px;
  background:rgba(0,0,0,.30);
}
.stat .k{ font-size:11px; color:var(--muted); letter-spacing:.10em; text-transform:uppercase; }
.stat .v{ margin-top:6px; font-size:18px; overflow-wrap:anywhere; text-shadow:0 0 10px rgba(57,255,106,.10); }

.hd{
  display:flex; justify-content:space-between; align-items:center;
  flex-wrap:wrap; gap:10px;
  padding:12px 14px;
  border-bottom:1px solid rgba(57,255,106,.2);
  background:linear-gradient(180deg, rgba(0,0,0,.22), rgba(0,0,0,0));
  position:relative;
}

.chip{
  border:1px solid rgba(57,255,106,.25);
  border-radius:999px;
  padding:6px 10px;
  font-size:10px; letter-spacing:.14em;
  display:inline-flex; align-items:center; gap:8px;
  background:rgba(0,0,0,.22);
  white-space:nowrap;
}
.dot{ width:8px;height:8px;border-radius:50%; background:var(--accent); box-shadow:var(--glow); }
.dot.warn{ background:var(--warn); box-shadow:0 0 18px rgba(255,211,77,.25); }
.dot.danger{ background:var(--danger); box-shadow:0 0 18px rgba(255,59,107,.25); }

button{
  font:inherit;
  border-radius:14px;
  border:1px solid rgba(57,255,106,.32);
  background:rgba(57,255,106,.08);
  color:var(--text);
  padding:14px;
  cursor:pointer;
  user-select:none;
  -webkit-tap-highlight-color:transparent;
  transition:.15s;
  touch-action:manipulation;
}
button:hover{ box-shadow:var(--glow); }
button:active{ transform:translateY(1px); }
button:disabled{ opacity:.5; cursor:not-allowed; box-shadow:none; }

.big{
  width:100%;
  font-weight:900;
  letter-spacing:.14em;
  font-size:18px;
  padding:18px 14px;
  background:linear-gradient(180deg, rgba(57,255,106,.16), rgba(57,255,106,.06));
  box-shadow: inset 0 0 0 1px rgba(57,255,106,.10);
}

.grid2{ display:grid; gap:10px; margin-top:12px; }
@media(min-width:420px){ .grid2{ grid-template-columns:1fr 1fr; } }

.muted{ margin-top:10px; font-size:12px; color:var(--muted); line-height:1.45; }

.bar{
  height:10px; border-radius:999px;
  border:1px solid rgba(57,255,106,.22);
  background:rgba(0,0,0,.28);
  overflow:hidden;
}
.fill{
  height:100%;
  width:0%;
  background:linear-gradient(90deg, rgba(57,255,106,.55), rgba(57,255,106,.20));
  box-shadow:0 0 18px rgba(57,255,106,.20);
}
.fill.danger{
  background:linear-gradient(90deg, rgba(255,59,107,.55), rgba(255,59,107,.18));
  box-shadow:0 0 18px rgba(255,59,107,.18);
}
.fill.warn{
  background:linear-gradient(90deg, rgba(255,211,77,.55), rgba(255,211,77,.18));
  box-shadow:0 0 18px rgba(255,211,77,.18);
}

.upgrades{ display:flex; flex-direction:column; gap:12px; }
.up{
  border:1px solid rgba(57,255,106,.2);
  border-radius:14px;
  padding:12px;
  background:rgba(0,0,0,.30);
  display:flex; flex-wrap:wrap;
  gap:12px; align-items:center;
  position:relative;
}
.up.affordable{ box-shadow:var(--glow); }
.up.locked{ opacity:.60; border-style:dashed; }

.up .meta{ flex:1; min-width:220px; }
.up .name{ font-weight:900; letter-spacing:.04em; }
.up .desc,.up .cost{ font-size:12px; margin-top:6px; color:var(--muted); }
.up .cost{ color:rgba(207,255,214,.90); }

.log{
  max-height:320px;
  overflow:auto;
  -webkit-overflow-scrolling:touch;
}
.log p{
  margin:0 0 10px;
  font-size:12px;
  line-height:1.55;
  color:rgba(207,255,214,.88);
}
.tag{
  display:inline-block;
  padding:2px 8px;
  border:1px solid rgba(57,255,106,.22);
  border-radius:999px;
  font-size:10px;
  letter-spacing:.10em;
  color:rgba(207,255,214,.95);
  margin-right:8px;
}

.flash{ animation:flash .18s ease-out; }
@keyframes flash{
  from{ box-shadow:0 0 30px rgba(57,255,106,.6); }
  to{ box-shadow:none; }
}

/* Array Scope canvas panel */
.scopeWrap{
  margin-top:10px;
  border:1px solid rgba(57,255,106,.22);
  border-radius:12px;
  background:rgba(0,0,0,.35);
  overflow:hidden;
}
.scopeTop{
  display:flex;
  justify-content:space-between;
  gap:10px;
  padding:8px 10px;
  border-bottom:1px solid rgba(57,255,106,.14);
  font-size:10px;
  letter-spacing:.12em;
  color:rgba(207,255,214,.92);
}
.scopeMeta{
  color:var(--muted);
  letter-spacing:.10em;
  text-transform:uppercase;
}
canvas#scope{
  display:block;
  width:100%;
  height:84px;
  background:rgba(0,0,0,.25);
}

/* Popup comm bubbles (tap to close) */
.popHost{
  position:fixed;
  top:12px;
  left:12px;
  right:12px;
  z-index:999;
  display:flex;
  flex-direction:column;
  gap:10px;
  pointer-events:auto;
  touch-action:pan-y;
}
.pop{
  pointer-events:auto;
  max-width:860px;
  margin:0 auto;
  border:1px solid rgba(57,255,106,.25);
  border-radius:14px;
  background:rgba(0,0,0,.72);
  box-shadow:0 10px 26px rgba(0,0,0,.55), 0 0 20px rgba(57,255,106,.15);
  padding:10px 12px;
  animation: popin .14s ease-out;
}
@keyframes popin{
  from{ transform:translateY(-6px); opacity:0; }
  to{ transform:translateY(0); opacity:1; }
}
.pop .who{
  font-size:10px;
  letter-spacing:.14em;
  color:rgba(126,219,146,.95);
  margin-bottom:6px;
  text-transform:uppercase;
}
.pop .msg{
  font-size:12px;
  line-height:1.5;
  color:rgba(207,255,214,.94);
}
.pop .hint{
  margin-top:6px;
  font-size:10px;
  letter-spacing:.12em;
  color:rgba(126,219,146,.85);
  text-transform:uppercase;
}
.pop.fade{
  animation: popout .18s ease-in forwards;
}
@keyframes popout{
  to{ transform:translateY(-4px); opacity:0; }
}

/* Modal confirm / prompt */
.modalHost{
  position:fixed; inset:0;
  z-index:2000;
  display:none;
  align-items:center;
  justify-content:center;
  padding:18px 14px calc(18px + env(safe-area-inset-bottom));
  background:rgba(0,0,0,.72);
  backdrop-filter: blur(4px);
}
.modal{
  width:min(860px, 100%);
  border:1px solid rgba(57,255,106,.30);
  border-radius:18px;
  background:linear-gradient(180deg, rgba(6,28,12,.86), rgba(3,14,7,.78));
  box-shadow:0 18px 40px rgba(0,0,0,.65), 0 0 22px rgba(57,255,106,.12);
  overflow:hidden;
}
.modal .mhd{
  padding:12px 14px;
  border-bottom:1px solid rgba(57,255,106,.18);
  display:flex; align-items:center; justify-content:space-between; gap:10px;
}
.modal .mtitle{
  font-weight:900; letter-spacing:.16em; font-size:12px; text-transform:uppercase;
  display:flex; align-items:center; gap:10px;
}
.modal .mbody{ padding:14px; font-size:12px; line-height:1.55; color:rgba(207,255,214,.92); }
.modal .mfoot{ padding:14px; padding-top:0; display:grid; gap:10px; }
@media(min-width:420px){ .modal .mfoot{ grid-template-columns:1fr 1fr; } }
.modal .dangerBtn{
  border-color:rgba(255,59,107,.42);
  background:rgba(255,59,107,.10);
}
.modal .dangerBtn:hover{ box-shadow:0 0 18px rgba(255,59,107,.18); }

.inputWrap{
  margin-top:10px;
  border:1px solid rgba(57,255,106,.22);
  border-radius:12px;
  background:rgba(0,0,0,.28);
  padding:10px;
}
.inputWrap label{
  display:block;
  font-size:10px;
  letter-spacing:.12em;
  color:rgba(126,219,146,.95);
  text-transform:uppercase;
  margin-bottom:8px;
}
.inputWrap input{
  width:100%;
  box-sizing:border-box;
  border-radius:12px;
  border:1px solid rgba(57,255,106,.25);
  background:rgba(0,0,0,.35);
  color:var(--text);
  padding:12px 12px;
  font:inherit;
  outline:none;
}
.inputWrap .hint{
  margin-top:8px;
  font-size:11px;
  color:rgba(126,219,146,.85);
  line-height:1.45;
}

/* Decoder */
.decoderStrip{
  margin-top:10px;
  border:1px solid rgba(57,255,106,.22);
  border-radius:12px;
  background:rgba(0,0,0,.35);
  padding:10px;
}
.decoderHeader{
  display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
  font-size:10px; letter-spacing:.14em; color:rgba(207,255,214,.92);
  text-transform:uppercase;
  margin-bottom:8px;
}
.decoderText{
  font-size:14px;
  letter-spacing:.12em;
  line-height:1.6;
  color:rgba(207,255,214,.95);
  word-break:break-word;
  text-shadow:0 0 10px rgba(57,255,106,.10);
}
.decoderControls{
  margin-top:10px;
  display:grid; gap:10px;
}
@media(min-width:420px){ .decoderControls{ grid-template-columns:1fr 1fr; } }
.smallBtn{
  padding:12px;
  font-size:12px;
  letter-spacing:.10em;
}
.decoderLocked{
  opacity:.70;
  border-style:dashed;
}

/* Clickable username chip */
#userChip{
  cursor:pointer;
}
#userChip:hover{
  box-shadow:var(--glow);
}
</style>
</head>

<body>
<div class="fx scanlines"></div>

<div class="popHost" id="popHost"></div>

<div class="modalHost" id="modalHost" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true">
    <div class="mhd">
      <div class="mtitle"><span class="dot warn" id="modalDot"></span><span id="modalTitle">CONFIRM</span></div>
      <span class="chip" id="modalTag">SYGN1L</span>
    </div>
    <div class="mbody" id="modalBody"></div>
    <div class="mfoot">
      <button class="smallBtn" id="modalCancel">CANCEL</button>
      <button class="smallBtn dangerBtn" id="modalOk">CONFIRM</button>
    </div>
  </div>
</div>

<div class="wrap">

  <header class="card">
    <div class="pad">
      <h1>SYGN1L</h1>
      <div class="subtitle">THE ARRAY LISTENS. THE VOID REPLIES IN ARITHMETIC.</div>

      <div class="stats">
        <div class="stat"><div class="k">SIGNAL</div><div class="v" id="signal">0</div></div>
        <div class="stat"><div class="k">SIGNAL/SEC</div><div class="v" id="sps">0</div></div>
        <div class="stat"><div class="k">BANDWIDTH</div><div class="v" id="bw">1.00×</div></div>
        <div class="stat"><div class="k">STABILITY</div><div class="v" id="stab">--</div></div>
      </div>

      <div class="scopeWrap">
        <div class="scopeTop">
          <div>ARRAY SCOPE</div>
          <div class="scopeMeta" id="scopeLabel">LOCK: 0%</div>
        </div>
        <canvas id="scope"></canvas>
      </div>

      <div style="height:10px"></div>
      <div class="stat">
        <div class="k">CORRUPTION</div>
        <div class="bar"><div class="fill danger" id="corrFill"></div></div>
        <div class="muted" id="corrText">0% (DORMANT)</div>
      </div>

      <div class="stat" style="margin-top:10px">
        <div class="k">INTEGRITY</div>
        <div class="bar"><div class="fill warn" id="intFill"></div></div>
        <div class="muted" id="intText">100% (CONTAINMENT OK)</div>
      </div>

      <div id="decoderCard" class="decoderStrip decoderLocked" style="display:none">
        <div class="decoderHeader">
          <div>XENO DECODER</div>
          <div id="decoderStatus">STATUS: ENCRYPTED</div>
        </div>
        <div class="decoderText" id="decoderText">///</div>
        <div class="decoderControls">
          <button class="smallBtn" id="engramBtn" disabled>DECRYPT ENGRAM</button>
          <button class="smallBtn" id="structEngramBtn" disabled>STRUCTURAL ENGRAM</button>
          <button class="smallBtn" id="cipherBtn" disabled>RESOLVE CIPHER (IRREVERSIBLE)</button>
          <button class="smallBtn" id="clusterBtn" disabled>SYMBOL CLUSTERING: OFF</button>
        </div>
        <div class="muted" id="decoderHint" style="margin-top:8px">
          INTERPRETATION REQUIRED. THE MESSAGE IS PRESENT BUT MISORDERED.
        </div>
      </div>

    </div>
  </header>

  <section class="card">
    <div class="hd">
      <div>
        <span class="chip"><span class="dot" id="phaseDot"></span><span id="phase">PHASE I</span></span>
        <span class="chip" id="status">ARRAY: STABLE</span>
        <span class="chip" id="buildChip">BUILD: 1</span>
        <span class="chip" id="relicChip">RELICS: 0</span>
      </div>
      <div>
        <span class="chip" id="syncChip">SYNC: LOCAL</span>
        <span class="chip" id="userChip" title="Tap to set username">USER: ----</span>
      </div>
    </div>

    <div class="pad">
      <button class="big" id="ping">PING THE VOID</button>

      <div class="grid2">
        <button id="save">SAVE</button>
        <button id="wipe">WIPE</button>
      </div>

      <div class="grid2">
        <button id="prestige" disabled>RITE RESET (LOCKED)</button>
        <button id="feedbackBtn">FEEDBACK: ON</button>
      </div>

      <div class="grid2">
        <button id="aiBtn">DYNAMIC COMMS: ON</button>
        <span class="chip" id="aiChip">AI: READY</span>
      </div>

      <div class="muted" id="objective">
        OBJECTIVE: ACQUIRE DISH CALIBRATION. REACH 100 TOTAL SIGNAL TO UNLOCK DEEP SCAN.
      </div>
    </div>
  </section>

  <section class="card">
    <div class="hd">
      <div>BUFFS</div>
      <div class="muted">UNLOCKED BY MILESTONES. AVAILABLE BUFFS GLOW.</div>
    </div>
    <div class="pad">
      <div class="upgrades" id="upgrades"></div>
    </div>
  </section>

  <section class="card">
    <div class="hd">
      <div>COMMUNICATIONS</div>
      <div class="muted">ANCILLARY CHANNELS REPORT STATUS</div>
    </div>
    <div class="pad">
      <div class="log" id="comms"></div>
    </div>
  </section>

  <section class="card">
    <div class="hd">
      <div>TRANSMISSION LOG</div>
      <div class="muted">MILESTONES REVEAL CONTEXT</div>
    </div>
    <div class="pad">
      <div class="log" id="log"></div>
    </div>
  </section>

</div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  // Prevent double-click zoom on buttons
  document.addEventListener("dblclick", (e) => {
    if (e.target && e.target.closest("button")) e.preventDefault();
  }, { passive: false });

  // Supabase Config (yours)
  const SUPABASE_URL = "https://qwrvlhdouicfyypxjffn.supabase.co";
  const SUPABASE_ANON_KEY = "sb_publishable_uBQsnY94g__2VzSm4Z9Yvg_mq32-ABR";
  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  // ===== Feedback (vibrate if possible, else tiny click)
  let feedbackOn = true;
  let audioCtx = null;

  function tinyClickSound(){
    if (!feedbackOn) return;
    try{
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const ctx = audioCtx;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = "square";
      o.frequency.value = 820;
      g.gain.value = 0.00001;
      o.connect(g); g.connect(ctx.destination);
      o.start();
      const t = ctx.currentTime;
      g.gain.setValueAtTime(0.00001, t);
      g.gain.exponentialRampToValueAtTime(0.028, t + 0.006);
      g.gain.exponentialRampToValueAtTime(0.00001, t + 0.050);
      o.stop(t + 0.055);
    } catch(_){}
  }
  function hapticPulse(ms=10){
    if (!feedbackOn) return false;
    if (navigator.vibrate){
      navigator.vibrate([ms]);
      return true;
    }
    return false;
  }
  function feedback(el, strength="light"){
    if (el){
      el.classList.remove("flash");
      void el.offsetWidth;
      el.classList.add("flash");
    }
    const h = (strength === "strong") ? hapticPulse(18) : hapticPulse(10);
    if (!h) tinyClickSound();
  }

  $("feedbackBtn").onclick = (e) => {
    feedbackOn = !feedbackOn;
    e.currentTarget.textContent = feedbackOn ? "FEEDBACK: ON" : "FEEDBACK: OFF";
    feedback(e.currentTarget, "light");
    markActive("toggle_feedback");
  };

  // ===== Modal confirm / prompt
  function confirmAction({title, body, okText="CONFIRM", cancelText="CANCEL", danger=true, tag="SYGN1L"}){
    return new Promise((resolve) => {
      const host = $("modalHost");
      $("modalTitle").textContent = title;
      $("modalBody").innerHTML = body;
      $("modalOk").textContent = okText;
      $("modalCancel").textContent = cancelText;
      $("modalTag").textContent = tag;

      const dot = $("modalDot");
      dot.className = "dot " + (danger ? "danger" : "warn");

      host.style.display = "flex";
      host.setAttribute("aria-hidden","false");

      let done = false;
      const cleanup = (val) => {
        if (done) return;
        done = true;
        host.style.display = "none";
        host.setAttribute("aria-hidden","true");
        $("modalOk").onclick = null;
        $("modalCancel").onclick = null;
        host.onclick = null;
        document.onkeydown = null;
        resolve(val);
      };

      $("modalOk").onclick = () => cleanup(true);
      $("modalCancel").onclick = () => cleanup(false);

      // click outside modal = cancel
      host.onclick = (ev) => {
        if (ev.target === host) cleanup(false);
      };

      // ESC cancels
      document.onkeydown = (ev) => {
        if (ev.key === "Escape") cleanup(false);
      };
    });
  }

  function promptAction({title, label, initialValue="", placeholder="", hint="", okText="SAVE", cancelText="CANCEL", danger=false, tag="PROFILE"}){
    return new Promise((resolve) => {
      const host = $("modalHost");
      $("modalTitle").textContent = title;

      const safeInit = String(initialValue ?? "");
      const safePH = String(placeholder ?? "");
      const safeLabel = String(label ?? "INPUT");

      $("modalBody").innerHTML = `
        <div>${hint ? hint : ""}</div>
        <div class="inputWrap">
          <label>${escapeHtml(safeLabel)}</label>
          <input id="modalInput" type="text" value="${escapeAttr(safeInit)}" placeholder="${escapeAttr(safePH)}" autocomplete="off" autocapitalize="none" spellcheck="false" />
          <div class="hint">3–16 chars. Letters/numbers/underscore. Example: <span class="tag">corey_01</span></div>
        </div>
      `;

      $("modalOk").textContent = okText;
      $("modalCancel").textContent = cancelText;
      $("modalTag").textContent = tag;

      const dot = $("modalDot");
      dot.className = "dot " + (danger ? "danger" : "warn");

      host.style.display = "flex";
      host.setAttribute("aria-hidden","false");

      let done = false;
      const input = () => document.getElementById("modalInput");

      const cleanup = (val) => {
        if (done) return;
        done = true;
        host.style.display = "none";
        host.setAttribute("aria-hidden","true");
        $("modalOk").onclick = null;
        $("modalCancel").onclick = null;
        host.onclick = null;
        document.onkeydown = null;
        resolve(val);
      };

      $("modalOk").onclick = () => cleanup(input()?.value ?? "");
      $("modalCancel").onclick = () => cleanup(null);

      host.onclick = (ev) => {
        if (ev.target === host) cleanup(null);
      };

      document.onkeydown = (ev) => {
        if (ev.key === "Escape") cleanup(null);
        if (ev.key === "Enter"){
          // only if focus is inside the input
          const i = input();
          if (i && document.activeElement === i){
            ev.preventDefault();
            cleanup(i.value ?? "");
          }
        }
      };

      // focus input
      setTimeout(() => {
        const i = input();
        if (i){
          i.focus();
          i.setSelectionRange(i.value.length, i.value.length);
        }
      }, 40);
    });
  }

  function escapeAttr(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  // ===== Utils
  function fmt(n){
    n = Number(n) || 0;
    if (n < 1000) return n.toFixed(0);
    const units = ["K","M","B","T","Qa","Qi"];
    let u = -1;
    while (n >= 1000 && u < units.length-1){ n /= 1000; u++; }
    return n.toFixed(n < 10 ? 2 : n < 100 ? 1 : 0) + units[u];
  }
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

  function pushLog(elId, tag, msg){
    const p = document.createElement("p");
    p.innerHTML = `<span class="tag">${tag}</span>${msg}`;
    $(elId).prepend(p);
  }

  // Tap-to-close popups; also auto-expire after 25s as safety.
  function popupComms(who, msg){
    const host = $("popHost");

    // keep at most 3 visible
    const kids = [...host.children];
    if (kids.length >= 3) kids[kids.length-1].remove();

    const box = document.createElement("div");
    box.className = "pop";
    box.innerHTML = `<div class="who">${escapeHtml(who || "COMMS")}</div><div class="msg">${escapeHtml(msg)}</div><div class="hint">TAP TO CLOSE</div>`;
    box.onclick = (e) => {
      e.stopPropagation();
      box.classList.add("fade");
      setTimeout(() => box.remove(), 190);
    };
    host.prepend(box);

    setTimeout(() => {
      if (!box.isConnected) return;
      box.classList.add("fade");
      setTimeout(() => box.remove(), 190);
    }, 25000);
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  // ===== Activity gating (AI never triggers while idling)
  let lastUserActionAt = 0;
  function markActive(reason){
    lastUserActionAt = Date.now();
  }
  window.addEventListener("pointerdown", () => markActive("pointer"), { passive:true });
  window.addEventListener("keydown", () => markActive("key"), { passive:true });

  function isActivelyUsed(){
    return (Date.now() - lastUserActionAt) <= 15000;
  }

  // ===== Username validation
  function normalizeUsername(raw){
    const s = String(raw ?? "").trim();
    if (!s) return "";
    // allow letters/numbers/underscore only
    const cleaned = s.replace(/[^A-Za-z0-9_]/g, "");
    return cleaned.slice(0, 16);
  }
  function isValidUsername(s){
    if (!s) return false;
    if (s.length < 3 || s.length > 16) return false;
    return /^[A-Za-z0-9_]+$/.test(s);
  }

  // ===== State
  const state = {
    build: 1,
    relics: 0,
    signal: 0,
    total: 0,

    baseSPS: 0,
    clickPower: 1,
    bandwidth: 1.0,
    autoPingsPerSec: 0,

    corruption: 0,
    integrity: 1.0,
    phase: 1,

    interpretation: 0,
    phase4: { active:false, shownOnce:false, repeatBursts:0 },
    phase5: { unlocked:false, unlockedAtMs:0, hasPrestigedSince:false, breachSeen:false },

    // NEW: profile
    profile: {
      username: "" // player-defined handle
    },

    flags: { sawPhase2:false, sawPhase3:false, sawPrestigeHint:false, sawPhase4:false, sawPhase5:false, sawWarning:false },

    upgrades: {
      dish: 0, probes: 0, scan: 0, tuning: 0,
      autopinger: 0, echo: 0, dark: 0, lattice: 0,
      relicAmp: 0,
      pattern: 0, semantic: 0, memory: 0, bleed: 0
    },

    decoder: {
      seeded: false,
      show: false,
      clustering: false,
      solved: false,
      scrambledOrder: [],
      revealed: {},
      decodedLetters: 0,
      structUsed: 0
    },

    updatedAtMs: 0,

    aiEnabled: true,
    lastAiAtMs: 0
  };
  window.SYGN1L_STATE = state;

  // ===== Message (Phase 5)
  const TARGET_MSG = "GREETINGS. THIS IS A WARNING. PREPARE FOR INVASION. THEY ARE COMING.";
  const LETTER_INDICES = (() => {
    const idx = [];
    for (let i=0;i<TARGET_MSG.length;i++){
      const ch = TARGET_MSG[i];
      if (/[A-Z]/.test(ch)) idx.push(i);
    }
    return idx;
  })();
  const TOTAL_LETTERS = LETTER_INDICES.length;

  // ===== Upgrades
  const UPG = [
    { id:"dish", name:"DISH CALIBRATION", unlockAt:0, baseCost:10, costMult:1.18,
      desc:"+1 SIGNAL/SEC PER LEVEL.", buy(){ state.upgrades.dish++; } },

    { id:"scan", name:"DEEP SCAN", unlockAt:100, baseCost:50, costMult:1.25,
      desc:"+10% BASE BANDWIDTH PER LEVEL.", buy(){ state.upgrades.scan++; } },

    { id:"probes", name:"PROBE SWARM", unlockAt:120, baseCost:80, costMult:1.22,
      desc:"+1 CLICK POWER PER LEVEL.", buy(){ state.upgrades.probes++; } },

    { id:"tuning", name:"HARMONIC TUNING", unlockAt:240, baseCost:140, costMult:1.27,
      desc:"+0.3 SIGNAL/SEC AND +1% BASE BANDWIDTH PER LEVEL.", buy(){ state.upgrades.tuning++; } },

    { id:"autopinger", name:"AUTO-PINGER ROUTINE", unlockAt:600, baseCost:520, costMult:1.30,
      desc:"ADDS AUTO-PINGS/SEC. SCALES WITH PROBES (SYNERGY).", buy(){ state.upgrades.autopinger++; } },

    { id:"echo", name:"ECHO INTEGRATOR", unlockAt:1800, baseCost:1400, costMult:1.35,
      desc:"BANDWIDTH BONUS: + (3%*LV) * LOG10(SIGNAL+1).", buy(){ state.upgrades.echo++; } },

    { id:"lattice", name:"HARMONIC LATTICE", unlockAt:3500, baseCost:3200, costMult:1.38,
      desc:"SPS MULT: (1 + 0.06*LV*SQRT(CORRUPTION*10)).", buy(){ state.upgrades.lattice++; } },

    { id:"dark", name:"DARK LISTENING", unlockAt:7000, baseCost:9000, costMult:1.45,
      desc:"IF CORRUPTION>30%: GAINS × (1 + 0.12*LV).", buy(){ state.upgrades.dark++; } },

    { id:"relicAmp", name:"RELIC AMPLIFIER", unlockAt:0, baseCost:3, costMult:1.65, currency:"relics",
      desc:"SPEND RELICS. PER LV: GLOBAL MULT +8% (PERMANENT).", buy(){ state.upgrades.relicAmp++; } },

    { id:"pattern", name:"PATTERN SAMPLER", unlockAt:25000, baseCost:4500, costMult:1.35, max:5, phase4:true,
      desc:"PHASE IV. LOCK EFFECT +3%/LV. QUIETLY ACCUMULATES INTERPRETATION.", buy(){ state.upgrades.pattern++; } },

    { id:"semantic", name:"SEMANTIC FILTER", unlockAt:25000, baseCost:7000, costMult:1.40, max:4, phase4:true,
      desc:"PHASE IV. +4% STABILITY/LV. (CLARITY HAS A COST.)", buy(){ state.upgrades.semantic++; } },

    { id:"memory", name:"STRUCTURAL MEMORY", unlockAt:9000, baseCost:2, costMult:0, currency:"relics", max:3, phase4:true,
      desc:"PHASE IV. PRESERVE LOCK +6%/LV ON RITE RESET. PRESERVES INTERPRETATION.", buy(){ state.upgrades.memory++; } },

    { id:"bleed", name:"SYMBOL BLEED", unlockAt:25000, baseCost:12000, costMult:1.0, max:1, phase4:true,
      desc:"PHASE IV. RARE VERTICAL ALIGNMENT EVENTS (INTERPRETATION BURSTS).", buy(){ state.upgrades.bleed = 1; } }
  ];

  function upgradeLevel(id){ return state.upgrades[id] || 0; }
  function upgradeCost(u){
    const lvl = upgradeLevel(u.id);
    if (u.id === "memory"){
      return 2 + (lvl * 2);
    }
    return Math.floor(u.baseCost * Math.pow(u.costMult, lvl));
  }
  function atMax(u){
    if (!u.max) return false;
    return upgradeLevel(u.id) >= u.max;
  }

  // ===== Derived math
  function computeBaseSPS(){
    return upgradeLevel("dish") * 1.0 + upgradeLevel("tuning") * 0.3;
  }
  function computeClickPower(){
    return 1 + upgradeLevel("probes") * 1.0;
  }
  function computeBaseBandwidth(){
    let bw = 1.0;
    bw *= Math.pow(1.10, upgradeLevel("scan"));
    bw *= Math.pow(1.01, upgradeLevel("tuning"));
    return bw;
  }
  function computeEchoMultiplier(){
    const lv = upgradeLevel("echo");
    if (lv <= 0) return 1.0;
    const logBonus = Math.log10(state.signal + 1);
    return 1 + (0.03 * lv * logBonus);
  }
  function computeRelicMultiplier(){
    const lv = upgradeLevel("relicAmp");
    return 1 + 0.08 * lv;
  }
  function computeLatticeMultiplier(){
    const lv = upgradeLevel("lattice");
    if (lv <= 0) return 1.0;
    const term = Math.sqrt(clamp(state.corruption,0,1) * 10);
    return 1 + 0.06 * lv * term;
  }
  function computeDarkMultiplier(){
    const lv = upgradeLevel("dark");
    if (lv <= 0) return 1.0;
    return state.corruption > 0.30 ? (1 + 0.12 * lv) : 1.0;
  }
  function computeAutoPingsPerSec(){
    const lv = upgradeLevel("autopinger");
    if (lv <= 0) return 0;
    const probeFactor = 1 + upgradeLevel("probes") * 0.15;
    return lv * 0.65 * probeFactor;
  }

  function recomputeDerived(){
    state.baseSPS = computeBaseSPS();
    state.clickPower = computeClickPower();
    state.bandwidth = computeBaseBandwidth() * computeEchoMultiplier() * computeRelicMultiplier();
    state.autoPingsPerSec = computeAutoPingsPerSec();
  }
  function computeSPS(){
    return state.baseSPS * state.bandwidth * computeLatticeMultiplier() * computeDarkMultiplier();
  }
  function globalMultiplier(){
    return state.bandwidth * computeLatticeMultiplier() * computeDarkMultiplier();
  }

  // ===== Corruption + Integrity + Stability
  function updateCorruption(dt){
    const creep = 0.0000025 * Math.log10(state.total + 10);
    const tech = (upgradeLevel("echo") * 0.0000015) + (upgradeLevel("lattice") * 0.0000018) + (upgradeLevel("dark") * 0.0000022);
    const invite = 0.0000010;
    state.corruption = clamp(state.corruption + (creep + tech + invite) * dt, 0, 1);
  }
  function corruptionLabel(c){
    if (c < 0.10) return "DORMANT";
    if (c < 0.30) return "WHISPERING";
    if (c < 0.60) return "INCIDENT";
    if (c < 0.85) return "BREACH";
    return "OVERRUN";
  }

  function stabilityValue(){
    const sem = upgradeLevel("semantic");
    const base = 0.55 + 0.04*sem;
    return clamp(base - 0.35*state.corruption, 0, 1);
  }

  function updateIntegrity(dt){
    const stab = stabilityValue();
    const risk = 0.003 + 0.020*state.corruption + 0.004*upgradeLevel("dark");
    const drain = risk * (1.10 - stab) * dt;
    const rec = (isActivelyUsed() ? (0.008 * stab) : 0.003 * stab) * dt;
    state.integrity = clamp(state.integrity - drain + rec, 0, 1);
  }

  function integrityLabel(i){
    if (i > 0.82) return "CONTAINMENT OK";
    if (i > 0.55) return "DRIFT";
    if (i > 0.30) return "INSTABILITY";
    if (i > 0.12) return "FAILURE";
    return "BREACH";
  }

  // ===== Gain
  function gain(amount){
    state.signal += amount;
    state.total += amount;
  }

  // ===== Save Manager (Local + Cloud)
  const LOCAL_KEY = "sygn1l_cloudsave_v5_username";
  let userId = null;
  let cloudReady = false;
  let lastCloudSaveAt = 0;

  function touchLocalUpdated(){
    state.updatedAtMs = Date.now();
  }

  function saveLocal(){
    touchLocalUpdated();
    localStorage.setItem(LOCAL_KEY, JSON.stringify(state));
    $("syncChip").textContent = cloudReady ? "SYNC: CLOUD+LOCAL" : "SYNC: LOCAL";
  }

  function loadLocal(){
    const raw = localStorage.getItem(LOCAL_KEY);
    if (!raw) return false;
    try{
      const data = JSON.parse(raw);
      mergeIntoState(data);
      return true;
    }catch(_){ return false; }
  }

  function mergeIntoState(data){
    for (const k in data){
      if (data[k] && typeof data[k] === "object" && state[k] && typeof state[k] === "object"){
        Object.assign(state[k], data[k]);
      } else {
        state[k] = data[k];
      }
    }
    // Backfill profile if older save
    state.profile = state.profile || { username:"" };
    if (typeof state.profile.username !== "string") state.profile.username = "";
  }

  async function ensureSession(){
    try{
      let { data: { session } } = await supabase.auth.getSession();
      if (!session){
        const { data, error } = await supabase.auth.signInAnonymously();
        if (error) throw error;
        session = data.session;
      }
      userId = session.user.id;
      cloudReady = true;
      $("syncChip").textContent = "SYNC: CLOUD";
      return userId;
    } catch(err){
      cloudReady = false;
      $("syncChip").textContent = "SYNC: OFFLINE";
      return null;
    }
  }

  async function loadCloud(){
    if (!cloudReady || !userId) return null;
    try{
      const { data, error } = await supabase
        .from("saves")
        .select("state, updated_at")
        .eq("player_id", userId)
        .maybeSingle();

      if (error) throw error;
      if (!data || !data.state) return null;

      const cloudState = data.state;
      const cloudUpdatedMs = cloudState.updatedAtMs || (data.updated_at ? Date.parse(data.updated_at) : 0);
      return { cloudState, cloudUpdatedMs };
    } catch(err){
      $("syncChip").textContent = "SYNC: OFFLINE";
      cloudReady = false;
      return null;
    }
  }

  async function saveCloud(force=false){
    if (!cloudReady || !userId) return false;

    const now = Date.now();
    if (!force && (now - lastCloudSaveAt) < 60000) return false;
    lastCloudSaveAt = now;

    try{
      touchLocalUpdated();
      const payload = {
        player_id: userId,
        updated_at: new Date().toISOString(),
        state: JSON.parse(JSON.stringify(state))
      };

      const { error } = await supabase.from("saves").upsert(payload);
      if (error) throw error;

      $("syncChip").textContent = "SYNC: CLOUD+LOCAL";
      return true;
    } catch(err){
      $("syncChip").textContent = "SYNC: OFFLINE";
      cloudReady = false;
      return false;
    }
  }

  // ===== Offline progress (Signal only)
  function applyOfflineProgress(){
    const lastMs = Number(state.updatedAtMs) || 0;
    if (!lastMs) return;

    const now = Date.now();
    let elapsed = (now - lastMs) / 1000;
    if (!isFinite(elapsed) || elapsed <= 2) return;

    const CAP = 8 * 60 * 60; // 8 hours
    const capped = Math.min(elapsed, CAP);

    recomputeDerived();
    const sps = computeSPS();
    const autoP = state.autoPingsPerSec || 0;

    const gainedFromSPS = Math.max(0, sps) * capped;
    const gainedFromAuto = Math.max(0, autoP) * capped * (state.clickPower * globalMultiplier());
    const totalGain = gainedFromSPS + gainedFromAuto;

    if (totalGain > 0){
      state.signal += totalGain;
      state.total += totalGain;
      const name = getUsernameOrAnon();
      popupComms("OPS", `${name}, while you were away: +${fmt(totalGain)} signal.`);
      pushLog("log","SYS",`OFFLINE RECOVERY: +${fmt(totalGain)} SIGNAL.`);
      touchLocalUpdated();
    }
  }

  async function initSaves(){
    const hasLocal = loadLocal();
    await ensureSession();
    const cloud = await loadCloud();

    if (cloud && cloud.cloudState){
      const localUpdated = state.updatedAtMs || 0;
      if (cloud.cloudUpdatedMs > localUpdated){
        mergeIntoState(cloud.cloudState);
        pushLog("log","SYS","CLOUD SAVE LOADED (NEWER THAN LOCAL).");
      } else if (cloudReady) {
        await saveCloud(true);
        pushLog("log","SYS","LOCAL SAVE PUSHED TO CLOUD (NEWER).");
      }
    } else {
      if (hasLocal){
        pushLog("log","SYS","LOCAL SAVE LOADED.");
      } else {
        pushLog("log","SYS","SYGN1L INITIALIZED. SILENCE IS UNPROCESSED DATA.");
        pushLog("comms","OPS","Start small. Ping it. If it answers, don’t answer back.");
        pushLog("comms","DR KESS","We’re not mining a signal. We’re excavating intent.");
      }
    }

    applyOfflineProgress();
    syncUserChip();
  }

  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "hidden"){
      saveLocal();
      saveCloud(true);
    }
  });

  // ===== Username UI
  function getUsernameOrAnon(){
    const u = (state.profile?.username || "").trim();
    return u ? u : "Operator";
  }

  function syncUserChip(){
    const u = (state.profile?.username || "").trim();
    if (u){
      $("userChip").textContent = "USER: " + u;
    } else if (userId){
      $("userChip").textContent = "USER: " + userId.slice(0,4) + "…" + userId.slice(-4);
    } else {
      $("userChip").textContent = "USER: ----";
    }
  }

  $("userChip").onclick = async () => {
    markActive("edit_username");
    feedback($("userChip"), "light");

    const current = state.profile?.username || "";
    const val = await promptAction({
      title: "SET USERNAME",
      label: "USERNAME",
      initialValue: current,
      placeholder: "corey_01",
      hint: "This name is stored in your save and can appear in dynamic comms.",
      okText: "SAVE",
      cancelText: "CANCEL",
      danger: false,
      tag: "PROFILE"
    });

    if (val === null) return;

    const cleaned = normalizeUsername(val);
    if (!isValidUsername(cleaned)){
      popupComms("SYS", "INVALID USERNAME. USE 3–16 CHARACTERS: A–Z, 0–9, _");
      return;
    }

    state.profile.username = cleaned;
    touchLocalUpdated();
    saveLocal();
    await saveCloud(true);

    syncUserChip();
    popupComms("OPS", `Acknowledged, ${cleaned}.`);
    pushLog("log","SYS",`USERNAME SET: <span class="tag">${escapeHtml(cleaned)}</span>`);
  };

  // ===== AI integration (via Supabase Edge Function)
  const AI_COOLDOWN_MS = 180000;

  function setAiChip(text){ $("aiChip").textContent = text; }

  $("aiBtn").onclick = (e) => {
    state.aiEnabled = !state.aiEnabled;
    e.currentTarget.textContent = state.aiEnabled ? "DYNAMIC COMMS: ON" : "DYNAMIC COMMS: OFF";
    setAiChip(state.aiEnabled ? "AI: READY" : "AI: DISABLED");
    touchLocalUpdated();
    saveLocal();
    feedback(e.currentTarget, "light");
    markActive("toggle_ai");
  };

  function aiReadyNow(){
    if (!state.aiEnabled) return false;
    if (!cloudReady) return false;
    if (!isActivelyUsed()) return false;
    const now = Date.now();
    if ((now - (state.lastAiAtMs || 0)) < AI_COOLDOWN_MS) return false;
    return true;
  }

  async function maybeAiComms(eventName, speakerHint){
    if (!aiReadyNow()) return;

    state.lastAiAtMs = Date.now();
    touchLocalUpdated();
    saveLocal();

    setAiChip("AI: THINKING");

    try{
      const payload = {
        event: eventName,
        speaker_hint: speakerHint || "OPS",
        username: (state.profile?.username || "").trim(),   // NEW
        phase: state.phase,
        build: state.build,
        signal: Math.floor(state.signal),
        total: Math.floor(state.total),
        sps: Math.floor(computeSPS()),
        bandwidth: Number(state.bandwidth.toFixed(2)),
        corruption: Number(state.corruption.toFixed(3)),
        integrity: Number(state.integrity.toFixed(3)),
        interpretation: Number(state.interpretation.toFixed(3)),
        decoded_letters: Number(state.decoder.decodedLetters || 0),
        solved: !!state.decoder.solved
      };

      const { data, error } = await supabase.functions.invoke("sygn1l-comms", { body: payload });
      if (error) throw error;

      const who = data?.who || speakerHint || "COMMS";
      let msg = data?.text || "…";

      // Optional: if your edge function doesn't yet use username, we can lightly weave it here.
      const uname = (state.profile?.username || "").trim();
      if (uname && typeof msg === "string" && Math.random() < 0.25){
        // safe, subtle personalization
        msg = msg.replace(/\bYOU\b/i, uname);
      }

      popupComms(who, msg);
      pushLog("comms", who, msg);

      setAiChip("AI: READY");
    } catch(err){
      setAiChip("AI: OFFLINE");
      pushLog("log","SYS","AI COMMS FAILED. (EDGE FUNCTION OR KEY NOT CONFIGURED)");
    }
  }

  // ===== UI render
  function renderHUD(){
    $("signal").textContent = fmt(state.signal);
    $("sps").textContent = fmt(computeSPS());
    $("bw").textContent = state.bandwidth.toFixed(2) + "×";

    const stab = stabilityValue();
    $("stab").textContent = Math.round(stab*100) + "%";

    const c = state.corruption;
    const visualSmooth = clamp(1 - 0.10*upgradeLevel("semantic"), 0.55, 1.0);
    const shown = clamp(c * visualSmooth, 0, 1);
    $("corrFill").style.width = (shown*100).toFixed(1) + "%";
    $("corrText").textContent = (c*100).toFixed(1) + "% (" + corruptionLabel(c) + ")";

    const i = state.integrity;
    $("intFill").style.width = (i*100).toFixed(1) + "%";
    $("intText").textContent = (i*100).toFixed(1) + "% (" + integrityLabel(i) + ")";

    syncUserChip();
  }

  // ===== Controls
  $("ping").addEventListener("click", async (e) => {
    markActive("ping");
    feedback(e.currentTarget, "light");

    gain(state.clickPower * globalMultiplier());
    state.corruption = clamp(state.corruption + 0.0006, 0, 1);

    const stab = stabilityValue();
    state.integrity = clamp(state.integrity - (0.0008 * (1.1 - stab)), 0, 1);

    touchLocalUpdated();
    renderHUD();
    saveLocal();
    await saveCloud(false);

    if (Math.random() < 0.10) {
      await maybeAiComms("ping_void", "OPS");
    }
  }, { passive:true });

  $("save").onclick = async (e) => {
    markActive("manual_save");
    feedback(e.currentTarget, "light");
    saveLocal();
    await saveCloud(true);
    pushLog("log","SYS","STATE SAVED.");
    await maybeAiComms("manual_save", "OPS");
  };

  $("wipe").onclick = async (e) => {
    markActive("wipe");
    feedback(e.currentTarget, "strong");

    const ok = await confirmAction({
      title: "WIPE",
      body: "This will delete your local save and your cloud save (if available).<br><br><span class='tag'>PERMANENT</span> Are you sure?",
      okText: "WIPE",
      cancelText: "CANCEL",
      danger: true,
      tag: "DATA"
    });
    if (!ok) return;

    localStorage.removeItem(LOCAL_KEY);
    if (cloudReady && userId){
      try{ await supabase.from("saves").delete().eq("player_id", userId); } catch(_){}
    }
    location.reload();
  };

  // ===== Init narrative if empty
  function bootNarrativeIfEmpty(){
    if ($("log").children.length === 0){
      pushLog("log","SYS","SYGN1L INITIALIZED. SILENCE IS UNPROCESSED DATA.");
      pushLog("comms","OPS","Start small. Ping it. If it answers, don’t answer back.");
      pushLog("comms","DR KESS","We’re not mining a signal. We’re excavating intent.");
    }
  }

  // ===== Start
  renderHUD();
  bootNarrativeIfEmpty();

  initSaves().then(() => {
    renderHUD();
    pushLog("log","SYS","SAVE SYSTEM ONLINE: LOCAL + CLOUD (WHEN AVAILABLE).");
    setAiChip(cloudReady ? (state.aiEnabled ? "AI: READY" : "AI: DISABLED") : "AI: OFFLINE");
  }).catch(() => {
    setAiChip("AI: OFFLINE");
  });

})();
</script>
</body>
</html>
