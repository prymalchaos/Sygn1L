<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<title>SYGN1L</title>

<style>
:root{
  --bg0:#020402; --bg1:#010701;
  --text:#CFFFD6; --muted:#7EDB92;
  --accent:#39FF6A; --danger:#FF3B6B; --warn:#FFD34D;
  --border:rgba(57,255,106,.25);
  --radius:16px; --shadow:0 10px 22px rgba(0,0,0,.55);
  --glow:0 0 18px rgba(57,255,106,.25);
}

html{ background:var(--bg0); -webkit-text-size-adjust:100%; }
body{
  margin:0;
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  color:var(--text);
  background:
    radial-gradient(900px 600px at 60% 15%, rgba(57,255,106,.10), transparent 60%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
  overflow-y:auto;
  -webkit-overflow-scrolling:touch;
  touch-action:manipulation;
  padding:14px 12px calc(24px + env(safe-area-inset-bottom));
}

/* CRT vignette */
body::before{
  content:"";
  position:fixed; inset:0;
  pointer-events:none;
  background: radial-gradient(1200px 900px at 50% 50%, rgba(0,0,0,0) 55%, rgba(0,0,0,.65) 100%);
  z-index:0;
}

/* scanlines */
.fx{ position:fixed; inset:0; pointer-events:none; z-index:0; }
.fx.scanlines{
  background:repeating-linear-gradient(
    to bottom,
    rgba(57,255,106,.05),
    rgba(57,255,106,.05) 1px,
    rgba(0,0,0,0) 4px,
    rgba(0,0,0,0) 8px
  );
  opacity:.24;
}

.wrap{
  position:relative; z-index:1;
  max-width:860px; margin:0 auto;
  display:grid; gap:18px;
}

.card{
  border:1px solid var(--border);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  background:linear-gradient(180deg, rgba(6,28,12,.62), rgba(3,14,7,.40));
  overflow:hidden;
  position:relative;
}
.card::after{
  content:"";
  position:absolute; inset:-2px;
  pointer-events:none;
  box-shadow: inset 0 0 0 1px rgba(57,255,106,.08), inset 0 0 22px rgba(57,255,106,.06);
}

.pad{ padding:14px; position:relative; }

h1{ margin:0; letter-spacing:.25em; font-size:18px; }
.subtitle{ margin-top:6px; font-size:12px; color:var(--muted); letter-spacing:.06em; }

.stats{
  margin-top:12px;
  display:grid; grid-template-columns:1fr;
  gap:10px;
}
@media(min-width:420px){ .stats{ grid-template-columns:repeat(3,1fr); } }

.stat{
  border:1px solid rgba(57,255,106,.2);
  border-radius:12px;
  padding:10px;
  background:rgba(0,0,0,.30);
}
.stat .k{ font-size:11px; color:var(--muted); letter-spacing:.10em; text-transform:uppercase; }
.stat .v{ margin-top:6px; font-size:18px; overflow-wrap:anywhere; text-shadow:0 0 10px rgba(57,255,106,.10); }

.hd{
  display:flex; justify-content:space-between; align-items:center;
  flex-wrap:wrap; gap:10px;
  padding:12px 14px;
  border-bottom:1px solid rgba(57,255,106,.2);
  background:linear-gradient(180deg, rgba(0,0,0,.22), rgba(0,0,0,0));
  position:relative;
}

.chip{
  border:1px solid rgba(57,255,106,.25);
  border-radius:999px;
  padding:6px 10px;
  font-size:10px; letter-spacing:.14em;
  display:inline-flex; align-items:center; gap:8px;
  background:rgba(0,0,0,.22);
  white-space:nowrap;
}
.dot{ width:8px;height:8px;border-radius:50%; background:var(--accent); box-shadow:var(--glow); }
.dot.warn{ background:var(--warn); box-shadow:0 0 18px rgba(255,211,77,.25); }
.dot.danger{ background:var(--danger); box-shadow:0 0 18px rgba(255,59,107,.25); }

button{
  font:inherit;
  border-radius:14px;
  border:1px solid rgba(57,255,106,.32);
  background:rgba(57,255,106,.08);
  color:var(--text);
  padding:14px;
  cursor:pointer;
  user-select:none;
  -webkit-tap-highlight-color:transparent;
  transition:.15s;
  touch-action:manipulation;
}
button:hover{ box-shadow:var(--glow); }
button:active{ transform:translateY(1px); }
button:disabled{ opacity:.5; cursor:not-allowed; box-shadow:none; }

.big{
  width:100%;
  font-weight:900;
  letter-spacing:.14em;
  font-size:18px;
  padding:18px 14px;
  background:linear-gradient(180deg, rgba(57,255,106,.16), rgba(57,255,106,.06));
  box-shadow: inset 0 0 0 1px rgba(57,255,106,.10);
}

.grid2{ display:grid; gap:10px; margin-top:12px; }
@media(min-width:420px){ .grid2{ grid-template-columns:1fr 1fr; } }

.muted{ margin-top:10px; font-size:12px; color:var(--muted); line-height:1.45; }

.bar{
  height:10px; border-radius:999px;
  border:1px solid rgba(57,255,106,.22);
  background:rgba(0,0,0,.28);
  overflow:hidden;
}
.fill{
  height:100%;
  width:0%;
  background:linear-gradient(90deg, rgba(57,255,106,.55), rgba(57,255,106,.20));
  box-shadow:0 0 18px rgba(57,255,106,.20);
}
.fill.danger{
  background:linear-gradient(90deg, rgba(255,59,107,.55), rgba(255,59,107,.18));
  box-shadow:0 0 18px rgba(255,59,107,.18);
}

.upgrades{ display:flex; flex-direction:column; gap:12px; }
.up{
  border:1px solid rgba(57,255,106,.2);
  border-radius:14px;
  padding:12px;
  background:rgba(0,0,0,.30);
  display:flex; flex-wrap:wrap;
  gap:12px; align-items:center;
  position:relative;
}
.up.affordable{ box-shadow:var(--glow); }
.up.locked{ opacity:.60; border-style:dashed; }

.up .meta{ flex:1; min-width:220px; }
.up .name{ font-weight:900; letter-spacing:.04em; }
.up .desc,.up .cost{ font-size:12px; margin-top:6px; color:var(--muted); }
.up .cost{ color:rgba(207,255,214,.90); }

.log{
  max-height:320px;
  overflow:auto;
  -webkit-overflow-scrolling:touch;
}
.log p{
  margin:0 0 10px;
  font-size:12px;
  line-height:1.55;
  color:rgba(207,255,214,.88);
}
.tag{
  display:inline-block;
  padding:2px 8px;
  border:1px solid rgba(57,255,106,.22);
  border-radius:999px;
  font-size:10px;
  letter-spacing:.10em;
  color:rgba(207,255,214,.95);
  margin-right:8px;
}

.flash{ animation:flash .18s ease-out; }
@keyframes flash{
  from{ box-shadow:0 0 30px rgba(57,255,106,.6); }
  to{ box-shadow:none; }
}

/* Array Scope canvas panel */
.scopeWrap{
  margin-top:10px;
  border:1px solid rgba(57,255,106,.22);
  border-radius:12px;
  background:rgba(0,0,0,.35);
  overflow:hidden;
}
.scopeTop{
  display:flex;
  justify-content:space-between;
  gap:10px;
  padding:8px 10px;
  border-bottom:1px solid rgba(57,255,106,.14);
  font-size:10px;
  letter-spacing:.12em;
  color:rgba(207,255,214,.92);
}
.scopeMeta{
  color:var(--muted);
  letter-spacing:.10em;
  text-transform:uppercase;
}
canvas#scope{
  display:block;
  width:100%;
  height:84px;
  background:rgba(0,0,0,.25);
}

/* Popup comm bubbles (tap to close) */
.popHost{
  position:fixed;
  top:12px;
  left:12px;
  right:12px;
  z-index:999;
  display:flex;
  flex-direction:column;
  gap:10px;
  pointer-events:auto;
  touch-action:pan-y;
}
.pop{
  pointer-events:auto;
  max-width:860px;
  margin:0 auto;
  border:1px solid rgba(57,255,106,.25);
  border-radius:14px;
  background:rgba(0,0,0,.72);
  box-shadow:0 10px 26px rgba(0,0,0,.55), 0 0 20px rgba(57,255,106,.15);
  padding:10px 12px;
  animation: popin .14s ease-out;
}
@keyframes popin{
  from{ transform:translateY(-6px); opacity:0; }
  to{ transform:translateY(0); opacity:1; }
}
.pop .who{
  font-size:10px;
  letter-spacing:.14em;
  color:rgba(126,219,146,.95);
  margin-bottom:6px;
  text-transform:uppercase;
}
.pop .msg{
  font-size:12px;
  line-height:1.5;
  color:rgba(207,255,214,.94);
}
.pop .hint{
  margin-top:6px;
  font-size:10px;
  letter-spacing:.12em;
  color:rgba(126,219,146,.85);
  text-transform:uppercase;
}
.pop.fade{ animation: popout .18s ease-in forwards; }
@keyframes popout{
  to{ transform:translateY(-4px); opacity:0; }
}

/* Modal confirm / prompt */
.modalHost{
  position:fixed; inset:0;
  z-index:2000;
  display:none;
  align-items:center;
  justify-content:center;
  padding:18px 14px calc(18px + env(safe-area-inset-bottom));
  background:rgba(0,0,0,.72);
  backdrop-filter: blur(4px);
}
.modal{
  width:min(860px, 100%);
  border:1px solid rgba(57,255,106,.30);
  border-radius:18px;
  background:linear-gradient(180deg, rgba(6,28,12,.86), rgba(3,14,7,.78));
  box-shadow:0 18px 40px rgba(0,0,0,.65), 0 0 22px rgba(57,255,106,.12);
  overflow:hidden;
}
.modal .mhd{
  padding:12px 14px;
  border-bottom:1px solid rgba(57,255,106,.18);
  display:flex; align-items:center; justify-content:space-between; gap:10px;
}
.modal .mtitle{
  font-weight:900; letter-spacing:.16em; font-size:12px; text-transform:uppercase;
  display:flex; align-items:center; gap:10px;
}
.modal .mbody{ padding:14px; font-size:12px; line-height:1.55; color:rgba(207,255,214,.92); }
.modal .mfoot{ padding:14px; padding-top:0; display:grid; gap:10px; }
@media(min-width:420px){ .modal .mfoot{ grid-template-columns:1fr 1fr; } }
.modal .dangerBtn{
  border-color:rgba(255,59,107,.42);
  background:rgba(255,59,107,.10);
}
.modal .dangerBtn:hover{ box-shadow:0 0 18px rgba(255,59,107,.18); }

.inputWrap{
  margin-top:10px;
  border:1px solid rgba(57,255,106,.22);
  border-radius:12px;
  background:rgba(0,0,0,.28);
  padding:10px;
}
.inputWrap label{
  display:block;
  font-size:10px;
  letter-spacing:.12em;
  color:rgba(126,219,146,.95);
  text-transform:uppercase;
  margin-bottom:8px;
}
.inputWrap input{
  width:100%;
  box-sizing:border-box;
  border-radius:12px;
  border:1px solid rgba(57,255,106,.25);
  background:rgba(0,0,0,.35);
  color:var(--text);
  padding:12px 12px;
  font:inherit;
  outline:none;
}
.inputWrap .hint{
  margin-top:8px;
  font-size:11px;
  color:rgba(126,219,146,.85);
  line-height:1.45;
}

/* Clickable username chip */
#userChip{ cursor:pointer; }
#userChip:hover{ box-shadow:var(--glow); }
</style>
</head>

<body>
<div class="fx scanlines"></div>

<div class="popHost" id="popHost"></div>

<div class="modalHost" id="modalHost" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true">
    <div class="mhd">
      <div class="mtitle"><span class="dot warn" id="modalDot"></span><span id="modalTitle">CONFIRM</span></div>
      <span class="chip" id="modalTag">SYGN1L</span>
    </div>
    <div class="mbody" id="modalBody"></div>
    <div class="mfoot">
      <button id="modalCancel">CANCEL</button>
      <button class="dangerBtn" id="modalOk">CONFIRM</button>
    </div>
  </div>
</div>

<div class="wrap">

  <header class="card">
    <div class="pad">
      <h1>SYGN1L</h1>
      <div class="subtitle">THE ARRAY LISTENS. THE VOID REPLIES IN ARITHMETIC.</div>

      <div class="stats">
        <div class="stat"><div class="k">SIGNAL</div><div class="v" id="signal">0</div></div>
        <div class="stat"><div class="k">SIGNAL/SEC</div><div class="v" id="sps">0</div></div>
        <div class="stat"><div class="k">BANDWIDTH</div><div class="v" id="bw">1.00×</div></div>
      </div>

      <div class="scopeWrap">
        <div class="scopeTop">
          <div>ARRAY SCOPE</div>
          <div class="scopeMeta" id="scopeLabel">LOCK: 0%</div>
        </div>
        <canvas id="scope"></canvas>
      </div>

      <div style="height:10px"></div>
      <div class="stat">
        <div class="k">CORRUPTION</div>
        <div class="bar"><div class="fill danger" id="corrFill"></div></div>
        <div class="muted" id="corrText">0% (DORMANT)</div>
      </div>
    </div>
  </header>

  <section class="card">
    <div class="hd">
      <div>
        <span class="chip"><span class="dot"></span><span id="phase">PHASE I</span></span>
        <span class="chip" id="status">ARRAY: STABLE</span>
        <span class="chip" id="buildChip">BUILD: 1</span>
        <span class="chip" id="relicChip">RELICS: 0</span>
      </div>
      <div>
        <span class="chip" id="syncChip">SYNC: LOCAL</span>
        <span class="chip" id="liveChip">LIVE: ACTIVE</span>
        <span class="chip" id="userChip" title="Tap to set username">USER: ----</span>
      </div>
    </div>

    <div class="pad">
      <button class="big" id="ping">PING THE VOID</button>

      <div class="grid2">
        <button id="save">SAVE</button>
        <button id="wipe">WIPE</button>
      </div>

      <div class="grid2">
        <button id="prestige" disabled>RITE RESET (LOCKED)</button>
        <button id="feedbackBtn">FEEDBACK: ON</button>
      </div>

      <div class="grid2">
        <button id="aiBtn">DYNAMIC COMMS: ON</button>
        <span class="chip" id="aiChip">AI: READY</span>
      </div>

      <div class="muted" id="objective">
        OBJECTIVE: ACQUIRE DISH CALIBRATION. REACH 100 TOTAL SIGNAL TO UNLOCK DEEP SCAN.
      </div>
    </div>
  </section>

  <section class="card">
    <div class="hd">
      <div>BUFFS</div>
      <div class="muted">UNLOCKED BY MILESTONES. AVAILABLE BUFFS GLOW.</div>
    </div>
    <div class="pad">
      <div class="upgrades" id="upgrades"></div>
    </div>
  </section>

  <section class="card">
    <div class="hd">
      <div>COMMUNICATIONS</div>
      <div class="muted">ANCILLARY CHANNELS REPORT STATUS</div>
    </div>
    <div class="pad">
      <div class="log" id="comms"></div>
    </div>
  </section>

  <section class="card">
    <div class="hd">
      <div>TRANSMISSION LOG</div>
      <div class="muted">ERRORS + MILESTONES SHOW UP HERE</div>
    </div>
    <div class="pad">
      <div class="log" id="log"></div>
    </div>
  </section>

</div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
(() => {
  "use strict";

  const $ = (id) => document.getElementById(id);

  // Prevent double-click zoom on buttons
  document.addEventListener("dblclick", (e) => {
    if (e.target && e.target.closest("button")) e.preventDefault();
  }, { passive: false });

  // ====== HTML escaping
  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }
  function escapeAttr(s){ return escapeHtml(s).replaceAll("`","&#096;"); }

  // ====== Logging with safety (never crash if log panel missing)
  function safePrepend(el, node){
    try{
      if (el && el.prepend) el.prepend(node);
    }catch(_){}
  }
  function pushLog(elId, tag, msg){
    const el = $(elId);
    const p = document.createElement("p");
    p.innerHTML = `<span class="tag">${escapeHtml(tag)}</span>${msg}`;
    safePrepend(el, p);
  }

  // Global error trap: surface crashes to the log
  window.addEventListener("error", (e) => {
    const msg = e?.message || "Unknown error";
    const where = e?.filename ? `${e.filename.split("/").slice(-1)[0]}:${e.lineno||0}` : "runtime";
    pushLog("log", "ERR", `${escapeHtml(msg)} <span class="tag">${escapeHtml(where)}</span>`);
  });
  window.addEventListener("unhandledrejection", (e) => {
    const msg = (e?.reason && (e.reason.message || String(e.reason))) || "Unhandled promise rejection";
    pushLog("log", "ERR", `${escapeHtml(msg)}`);
  });

  // ===== Popup comm bubbles (tap to close)
  function popupComms(who, msg){
    const host = $("popHost");
    if (!host) return;

    const kids = [...host.children];
    if (kids.length >= 3) kids[kids.length-1].remove();

    const box = document.createElement("div");
    box.className = "pop";
    box.innerHTML = `<div class="who">${escapeHtml(who)}</div><div class="msg">${escapeHtml(msg)}</div><div class="hint">TAP TO CLOSE</div>`;
    box.onclick = (e) => {
      e.stopPropagation();
      box.classList.add("fade");
      setTimeout(() => box.remove(), 190);
    };
    host.prepend(box);

    setTimeout(() => {
      if (!box.isConnected) return;
      box.classList.add("fade");
      setTimeout(() => box.remove(), 190);
    }, 25000);
  }

  // ===== Feedback (vibrate if possible, else tiny click)
  let feedbackOn = true;
  let audioCtx = null;
  function tinyClickSound(){
    if (!feedbackOn) return;
    try{
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const ctx = audioCtx;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = "square";
      o.frequency.value = 820;
      g.gain.value = 0.00001;
      o.connect(g); g.connect(ctx.destination);
      o.start();
      const t = ctx.currentTime;
      g.gain.setValueAtTime(0.00001, t);
      g.gain.exponentialRampToValueAtTime(0.028, t + 0.006);
      g.gain.exponentialRampToValueAtTime(0.00001, t + 0.050);
      o.stop(t + 0.055);
    } catch(_){}
  }
  function hapticPulse(ms=10){
    if (!feedbackOn) return false;
    if (navigator.vibrate){
      navigator.vibrate([ms]);
      return true;
    }
    return false;
  }
  function feedback(el, strength="light"){
    if (el){
      el.classList.remove("flash");
      void el.offsetWidth;
      el.classList.add("flash");
    }
    const ok = (strength === "strong") ? hapticPulse(18) : hapticPulse(10);
    if (!ok) tinyClickSound();
  }

  // ===== Modal confirm / prompt
  function confirmAction({title, body, okText="CONFIRM", cancelText="CANCEL", danger=true, tag="SYGN1L"}){
    return new Promise((resolve) => {
      const host = $("modalHost");
      if (!host) return resolve(false);

      $("modalTitle").textContent = title;
      $("modalBody").innerHTML = body;
      $("modalOk").textContent = okText;
      $("modalCancel").textContent = cancelText;
      $("modalTag").textContent = tag;

      const dot = $("modalDot");
      dot.className = "dot " + (danger ? "danger" : "warn");

      host.style.display = "flex";
      host.setAttribute("aria-hidden","false");

      let done = false;
      const cleanup = (val) => {
        if (done) return;
        done = true;
        host.style.display = "none";
        host.setAttribute("aria-hidden","true");
        $("modalOk").onclick = null;
        $("modalCancel").onclick = null;
        host.onclick = null;
        document.onkeydown = null;
        resolve(val);
      };

      $("modalOk").onclick = () => cleanup(true);
      $("modalCancel").onclick = () => cleanup(false);

      host.onclick = (ev) => { if (ev.target === host) cleanup(false); };
      document.onkeydown = (ev) => { if (ev.key === "Escape") cleanup(false); };
    });
  }

  function promptAction({title, label, initialValue="", placeholder="", hint="", okText="SAVE", cancelText="CANCEL", danger=false, tag="PROFILE"}){
    return new Promise((resolve) => {
      const host = $("modalHost");
      if (!host) return resolve(null);

      $("modalTitle").textContent = title;
      $("modalBody").innerHTML = `
        <div>${hint ? hint : ""}</div>
        <div class="inputWrap">
          <label>${escapeHtml(label || "INPUT")}</label>
          <input id="modalInput" type="text" value="${escapeAttr(initialValue)}" placeholder="${escapeAttr(placeholder)}"
                 autocomplete="off" autocapitalize="none" spellcheck="false" />
          <div class="hint">3–16 chars. Letters/numbers/underscore only. Example: <span class="tag">corey_01</span></div>
        </div>
      `;

      $("modalOk").textContent = okText;
      $("modalCancel").textContent = cancelText;
      $("modalTag").textContent = tag;

      const dot = $("modalDot");
      dot.className = "dot " + (danger ? "danger" : "warn");

      host.style.display = "flex";
      host.setAttribute("aria-hidden","false");

      let done = false;
      const input = () => document.getElementById("modalInput");

      const cleanup = (val) => {
        if (done) return;
        done = true;
        host.style.display = "none";
        host.setAttribute("aria-hidden","true");
        $("modalOk").onclick = null;
        $("modalCancel").onclick = null;
        host.onclick = null;
        document.onkeydown = null;
        resolve(val);
      };

      $("modalOk").onclick = () => cleanup(input()?.value ?? "");
      $("modalCancel").onclick = () => cleanup(null);

      host.onclick = (ev) => { if (ev.target === host) cleanup(null); };
      document.onkeydown = (ev) => {
        if (ev.key === "Escape") cleanup(null);
        if (ev.key === "Enter"){
          const i = input();
          if (i && document.activeElement === i){
            ev.preventDefault();
            cleanup(i.value ?? "");
          }
        }
      };

      setTimeout(() => {
        const i = input();
        if (i){
          i.focus();
          i.setSelectionRange(i.value.length, i.value.length);
        }
      }, 50);
    });
  }

  // ===== Utils
  function fmt(n){
    n = Number(n) || 0;
    if (n < 1000) return n.toFixed(0);
    const units = ["K","M","B","T","Qa","Qi"];
    let u = -1;
    while (n >= 1000 && u < units.length-1){ n /= 1000; u++; }
    return n.toFixed(n < 10 ? 2 : n < 100 ? 1 : 0) + units[u];
  }
  function clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

  // ===== Activity gating (AI never triggers while idling)
  let lastUserActionAt = 0;
  function markActive(){ lastUserActionAt = Date.now(); }
  window.addEventListener("pointerdown", markActive, { passive:true });
  window.addEventListener("keydown", markActive, { passive:true });
  function isActivelyUsed(){ return (Date.now() - lastUserActionAt) <= 15000; }

  // ===== Username validation
  function normalizeUsername(raw){
    const s = String(raw ?? "").trim();
    if (!s) return "";
    return s.replace(/[^A-Za-z0-9_]/g, "").slice(0, 16);
  }
  function isValidUsername(s){
    if (!s) return false;
    if (s.length < 3 || s.length > 16) return false;
    return /^[A-Za-z0-9_]+$/.test(s);
  }

  // ===== LIVE status chip
  let lastLiveLabel = "";
  let offlineRecoveryFlag = false;
  function setLive(label){
    if (label === lastLiveLabel) return;
    lastLiveLabel = label;
    const chip = $("liveChip");
    if (chip) chip.textContent = "LIVE: " + label;
  }
  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "hidden") setLive("HIDDEN");
    else setLive("ACTIVE");
  });

  // ===== State
  const state = {
    build: 1,
    relics: 0,
    signal: 0,
    total: 0,

    baseSPS: 0,
    clickPower: 1,
    bandwidth: 1.0,
    autoPingsPerSec: 0,

    corruption: 0,
    phase: 1,

    flags: {
      sawPhase2:false, sawPhase3:false, sawPrestigeHint:false,
      warnedCorrupt30:false
    },

    upgrades: {
      dish: 0, probes: 0, scan: 0, tuning: 0,
      autopinger: 0, echo: 0, dark: 0, lattice: 0,
      relicAmp: 0
    },

    profile: { username:"" },

    tutorial: {
      welcomed: false,
      firstPing: false,
      dishHint: false,
      scanHint: false,
      probesHint: false,
      autopingerHint: false
    },

    updatedAtMs: 0,

    aiEnabled: true,
    lastAiAtMs: 0
  };

  // ===== Conversational comms helper
  function playerName(){
    const u = (state.profile?.username || "").trim();
    return u ? u : "Operator";
  }
  function say(who, msg, { popup=true, log=true } = {}){
    const text = String(msg).replaceAll("{user}", playerName());
    if (popup) popupComms(who, text);
    if (log) pushLog("comms", who, escapeHtml(text));
  }

  // ===== Upgrades data
  const UPG = [
    { id:"dish", name:"DISH CALIBRATION", unlockAt:0, baseCost:10, costMult:1.18,
      desc:"+1 SIGNAL/SEC PER LEVEL.", buy(){ state.upgrades.dish++; } },
    { id:"scan", name:"DEEP SCAN", unlockAt:100, baseCost:50, costMult:1.25,
      desc:"+10% BASE BANDWIDTH PER LEVEL.", buy(){ state.upgrades.scan++; } },
    { id:"probes", name:"PROBE SWARM", unlockAt:120, baseCost:80, costMult:1.22,
      desc:"+1 CLICK POWER PER LEVEL.", buy(){ state.upgrades.probes++; } },
    { id:"tuning", name:"HARMONIC TUNING", unlockAt:240, baseCost:140, costMult:1.27,
      desc:"+0.3 SIGNAL/SEC AND +1% BASE BANDWIDTH PER LEVEL.", buy(){ state.upgrades.tuning++; } },
    { id:"autopinger", name:"AUTO-PINGER ROUTINE", unlockAt:600, baseCost:520, costMult:1.30,
      desc:"ADDS AUTO-PINGS/SEC. SCALES WITH PROBES (SYNERGY).", buy(){ state.upgrades.autopinger++; } },
    { id:"echo", name:"ECHO INTEGRATOR", unlockAt:1800, baseCost:1400, costMult:1.35,
      desc:"BANDWIDTH BONUS: + (3%*LV) * LOG10(SIGNAL+1).", buy(){ state.upgrades.echo++; } },
    { id:"lattice", name:"HARMONIC LATTICE", unlockAt:3500, baseCost:3200, costMult:1.38,
      desc:"SPS MULT: (1 + 0.06*LV*SQRT(CORRUPTION*10)).", buy(){ state.upgrades.lattice++; } },
    { id:"dark", name:"DARK LISTENING", unlockAt:7000, baseCost:9000, costMult:1.45,
      desc:"IF CORRUPTION>30%: GAINS × (1 + 0.12*LV).", buy(){ state.upgrades.dark++; } },
    { id:"relicAmp", name:"RELIC AMPLIFIER", unlockAt:0, baseCost:3, costMult:1.65, currency:"relics",
      desc:"SPEND RELICS. PER LV: GLOBAL MULT +8% (PERMANENT).", buy(){ state.upgrades.relicAmp++; } }
  ];

  function upgradeLevel(id){ return state.upgrades[id] || 0; }
  function upgradeCost(u){
    const lvl = upgradeLevel(u.id);
    return Math.floor(u.baseCost * Math.pow(u.costMult, lvl));
  }

  // ===== Derived math
  function computeBaseSPS(){
    return upgradeLevel("dish") * 1.0 + upgradeLevel("tuning") * 0.3;
  }
  function computeClickPower(){
    return 1 + upgradeLevel("probes") * 1.0;
  }
  function computeBaseBandwidth(){
    let bw = 1.0;
    bw *= Math.pow(1.10, upgradeLevel("scan"));
    bw *= Math.pow(1.01, upgradeLevel("tuning"));
    return bw;
  }
  function computeEchoMultiplier(){
    const lv = upgradeLevel("echo");
    if (lv <= 0) return 1.0;
    const logBonus = Math.log10(state.signal + 1);
    return 1 + (0.03 * lv * logBonus);
  }
  function computeRelicMultiplier(){
    const lv = upgradeLevel("relicAmp");
    return 1 + 0.08 * lv;
  }
  function computeLatticeMultiplier(){
    const lv = upgradeLevel("lattice");
    if (lv <= 0) return 1.0;
    const term = Math.sqrt(clamp(state.corruption,0,1) * 10);
    return 1 + 0.06 * lv * term;
  }
  function computeDarkMultiplier(){
    const lv = upgradeLevel("dark");
    if (lv <= 0) return 1.0;
    return state.corruption > 0.30 ? (1 + 0.12 * lv) : 1.0;
  }
  function computeAutoPingsPerSec(){
    const lv = upgradeLevel("autopinger");
    if (lv <= 0) return 0;
    const probeFactor = 1 + upgradeLevel("probes") * 0.15;
    return lv * 0.65 * probeFactor;
  }
  function recomputeDerived(){
    state.baseSPS = computeBaseSPS();
    state.clickPower = computeClickPower();
    state.bandwidth = computeBaseBandwidth() * computeEchoMultiplier() * computeRelicMultiplier();
    state.autoPingsPerSec = computeAutoPingsPerSec();
  }
  function computeSPS(){
    return state.baseSPS * state.bandwidth * computeLatticeMultiplier() * computeDarkMultiplier();
  }
  function globalMultiplier(){
    return state.bandwidth * computeLatticeMultiplier() * computeDarkMultiplier();
  }

  // ===== Corruption
  function updateCorruption(dt){
    const creep = 0.0000025 * Math.log10(state.total + 10);
    const tech = (upgradeLevel("echo") * 0.0000015) + (upgradeLevel("lattice") * 0.0000018) + (upgradeLevel("dark") * 0.0000022);
    const invite = 0.0000010;
    state.corruption = clamp(state.corruption + (creep + tech + invite) * dt, 0, 1);
  }
  function corruptionLabel(c){
    if (c < 0.10) return "DORMANT";
    if (c < 0.30) return "WHISPERING";
    if (c < 0.60) return "INCIDENT";
    if (c < 0.85) return "BREACH";
    return "OVERRUN";
  }

  // ===== Objectives & milestones
  function setObjective(text){
    const el = $("objective");
    if (el) el.innerHTML = "OBJECTIVE: " + text;
  }

  function milestoneCheck(){
    if (!state.flags.sawPhase2 && state.total >= 500){
      state.flags.sawPhase2 = true;
      state.phase = Math.max(state.phase, 2);
      $("phase").textContent = "PHASE II";
      $("status").textContent = "ARRAY: DRIFT";
      pushLog("log","SYS","PHASE II ENGAGED. THE ARRAY BEGINS RETURN TRANSMISSIONS.");
      say("LT VANCE","If this thing talks back, we log it. If it begs, we mute it.");
      setObjective("REACH 600 TOTAL SIGNAL TO UNLOCK AUTO-PINGER ROUTINE. INCREASE SIGNAL/SEC.");
    }
    if (!state.flags.sawPhase3 && state.total >= 1800){
      state.flags.sawPhase3 = true;
      state.phase = Math.max(state.phase, 3);
      $("phase").textContent = "PHASE III";
      $("status").textContent = "ARRAY: ACTIVE";
      pushLog("log","SYS","PHASE III: RESPONSE PATTERNS DETECTED. NOT RANDOM. NOT FRIENDLY.");
      say("DR KESS","It’s not a signal. It’s an instruction set pretending to be noise.");
      setObjective("REACH 3500 TOTAL SIGNAL TO UNLOCK HARMONIC LATTICE. WATCH CORRUPTION.");
    }
    if (!state.flags.sawPrestigeHint && state.total >= 9000){
      state.flags.sawPrestigeHint = true;
      say("OPS","We can reset the Array and keep the residue. Call it a Rite. We’ll call it insurance.");
      pushLog("log","SYS","RITE RESET PROTOCOL DISCOVERED. RELICS MAY PERSIST BETWEEN BUILDS.");
      setObjective("REACH 12,000 TOTAL SIGNAL TO UNLOCK RITE RESET.");
    }
  }

  function updateObjectiveFallback(){
    if (!state.flags.sawPhase2){
      setObjective("ACQUIRE DISH CALIBRATION. REACH 100 TOTAL SIGNAL TO UNLOCK DEEP SCAN.");
    } else if (!state.flags.sawPhase3){
      setObjective("UNLOCK AUTO-PINGER ROUTINE AT 600 TOTAL SIGNAL. PUSH SIGNAL/SEC UP.");
    } else if (state.total < 12000){
      setObjective("UNLOCK HARMONIC LATTICE AT 3500 TOTAL SIGNAL. PREPARE FOR RITE RESET AT 12,000.");
    } else {
      setObjective("RITE RESET AVAILABLE. CONSIDER RESETTING FOR RELICS (PERMANENT POWER).");
    }
  }

  // ===== Tutorial guidance
  function tutorialCheck(){
    if (!state.tutorial.welcomed){
      state.tutorial.welcomed = true;
      say("OPS","Alright {user}, you’re on Array duty. Tap PING to wake the receiver.");
      say("TECH RIV","Then grab DISH CALIBRATION in BUFFS so Signal keeps rising while you breathe.", {popup:true, log:true});
    }
    if (!state.tutorial.dishHint && state.total >= 10 && (state.upgrades.dish||0) === 0){
      state.tutorial.dishHint = true;
      say("TECH RIV","You’ve got enough Signal. Buy DISH CALIBRATION. That’s our baseline stability.");
    }
    if (!state.tutorial.scanHint && state.total >= 100 && (state.upgrades.scan||0) === 0){
      state.tutorial.scanHint = true;
      say("DR KESS","Deep Scan is online. It increases bandwidth. Bandwidth multiplies your progress.");
    }
    if (!state.tutorial.probesHint && state.total >= 120 && (state.upgrades.probes||0) === 0){
      state.tutorial.probesHint = true;
      say("LT VANCE","Buy PROBE SWARM if you’re tapping a lot. More click power, less time wasted.");
    }
    if (!state.tutorial.autopingerHint && state.total >= 600 && (state.upgrades.autopinger||0) === 0){
      state.tutorial.autopingerHint = true;
      say("OPS","Auto-Pinger unlocked. Now the Array works even when you’re not babysitting it.");
    }
  }

  // ===== Banter (cooldown)
  const banter = {
    ping: [
      "Pulse logged. The noise looks… opinionated today.",
      "That one stung. Did you feel it, or am I projecting again?",
      "Signal integrity nudged upward. Keep going, {user}.",
      "I hate how quickly it learns your rhythm."
    ],
    upgrade: [
      "Nice. Hardware likes certainty. Whatever is out there prefers ambiguity.",
      "Budget approval denied by reality. Approved by curiosity.",
      "That upgrade will increase throughput… and attention. Careful.",
      "Every improvement makes the Array easier to hear… and harder to ignore."
    ],
    corruption: [
      "Corruption is climbing. It’s not an error. It’s an invitation.",
      "We should not be this proud of a system that’s quietly rotting.",
      "If you hear your name in the static, do not answer."
    ]
  };
  let lastBanterAt = 0;
  function maybeBanter(type){
    const now = Date.now();
    if (now - lastBanterAt < 45000) return;
    lastBanterAt = now;
    const list = banter[type] || [];
    if (!list.length) return;
    const msg = list[Math.floor(Math.random()*list.length)];
    const who = (type === "corruption") ? "DR KESS" : (type === "upgrade" ? "OPS" : "TECH RIV");
    say(who, msg);
  }

  // ===== Prestige
  function prestigeGain(){
    const over = Math.max(0, state.total - 12000);
    const base = 1;
    const extra = Math.floor(Math.sqrt(over / 6000));
    return base + extra;
  }
  function doPrestige(){
    const gainRelics = prestigeGain();
    state.relics += gainRelics;
    state.build += 1;

    pushLog("log","SYS",`RITE RESET EXECUTED. +${gainRelics} RELICS RECOVERED.`);
    say("MOTHERLINE","THE ARRAY FORGETS. YOU DO NOT.");

    const keepRelicAmp = state.upgrades.relicAmp || 0;
    const keepUsername = (state.profile?.username || "");

    state.signal = 0;
    state.total = 0;
    state.corruption = Math.max(0, state.corruption * 0.25);
    state.phase = 1;

    state.flags.sawPhase2 = false;
    state.flags.sawPhase3 = false;
    state.flags.sawPrestigeHint = false;
    state.flags.warnedCorrupt30 = false;

    for (const k in state.upgrades) state.upgrades[k] = 0;
    state.upgrades.relicAmp = keepRelicAmp;
    state.profile.username = keepUsername;

    touchLocalUpdated();
    recomputeDerived();
    updateObjectiveFallback();
  }

  // ===== Gain
  function gain(amount){
    state.signal += amount;
    state.total += amount;
  }

  // ===== Save Manager (Local + Cloud)
  const LOCAL_KEY = "sygn1l_full_v8_hardened";
  function touchLocalUpdated(){ state.updatedAtMs = Date.now(); }
  function saveLocal(){
    touchLocalUpdated();
    try{ localStorage.setItem(LOCAL_KEY, JSON.stringify(state)); }catch(_){}
  }
  function mergeIntoState(data){
    for (const k in data){
      if (data[k] && typeof data[k] === "object" && state[k] && typeof state[k] === "object"){
        Object.assign(state[k], data[k]);
      } else {
        state[k] = data[k];
      }
    }
    state.profile = state.profile || { username:"" };
    state.tutorial = state.tutorial || {};
    state.flags = state.flags || {};
    state.upgrades = state.upgrades || {};
  }
  function loadLocal(){
    try{
      const raw = localStorage.getItem(LOCAL_KEY);
      if (!raw) return false;
      mergeIntoState(JSON.parse(raw));
      return true;
    }catch(_){ return false; }
  }

  // ===== Supabase (optional): game still runs without it
  const SUPABASE_URL = "https://qwrvlhdouicfyypxjffn.supabase.co";
  const SUPABASE_ANON_KEY = "sb_publishable_uBQsnY94g__2VzSm4Z9Yvg_mq32-ABR";

  let supabase = null;
  let userId = null;
  let cloudReady = false;
  let lastCloudSaveAt = 0;

  function setSyncChip(){
    const el = $("syncChip");
    if (!el) return;
    el.textContent = cloudReady ? "SYNC: CLOUD" : "SYNC: LOCAL";
  }

  async function initSupabase(){
    try{
      if (!window.supabase || !window.supabase.createClient) throw new Error("Supabase SDK missing");
      supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

      let { data: { session } } = await supabase.auth.getSession();
      if (!session){
        const { data, error } = await supabase.auth.signInAnonymously();
        if (error) throw error;
        session = data.session;
      }

      userId = session.user.id;
      cloudReady = true;
      setSyncChip();
    } catch(err){
      cloudReady = false;
      setSyncChip();
      pushLog("log","SYS","CLOUD SYNC OFFLINE. LOCAL MODE ACTIVE.");
    }
  }

  async function saveCloud(force=false){
    if (!cloudReady || !supabase || !userId) return false;

    const now = Date.now();
    if (!force && (now - lastCloudSaveAt) < 60000) return false;
    lastCloudSaveAt = now;

    try{
      touchLocalUpdated();
      const payload = {
        player_id: userId,
        updated_at: new Date().toISOString(),
        state: JSON.parse(JSON.stringify(state))
      };
      const { error } = await supabase.from("saves").upsert(payload);
      if (error) throw error;
      return true;
    } catch(_){
      cloudReady = false;
      setSyncChip();
      pushLog("log","SYS","CLOUD SAVE FAILED. LOCAL CONTINUES.");
      return false;
    }
  }

  async function loadCloudIfNewer(){
    if (!cloudReady || !supabase || !userId) return false;
    try{
      const { data, error } = await supabase
        .from("saves")
        .select("state, updated_at")
        .eq("player_id", userId)
        .maybeSingle();
      if (error) throw error;
      if (!data || !data.state) return false;

      const cloudState = data.state;
      const cloudUpdatedMs = cloudState.updatedAtMs || (data.updated_at ? Date.parse(data.updated_at) : 0);
      const localUpdated = state.updatedAtMs || 0;

      if (cloudUpdatedMs > localUpdated){
        mergeIntoState(cloudState);
        pushLog("log","SYS","CLOUD SAVE LOADED (NEWER).");
        return true;
      }
      return false;
    } catch(_){
      cloudReady = false;
      setSyncChip();
      pushLog("log","SYS","CLOUD LOAD FAILED. LOCAL CONTINUES.");
      return false;
    }
  }

  // Offline progress capped 8 hours
  function applyOfflineProgress(){
    offlineRecoveryFlag = true;
    const lastMs = Number(state.updatedAtMs) || 0;
    if (!lastMs){
      offlineRecoveryFlag = false;
      return;
    }
    const now = Date.now();
    let elapsed = (now - lastMs) / 1000;
    if (!isFinite(elapsed) || elapsed <= 2){
      offlineRecoveryFlag = false;
      return;
    }
    const CAP = 8 * 60 * 60;
    const capped = Math.min(elapsed, CAP);

    recomputeDerived();
    const sps = computeSPS();
    const autoP = state.autoPingsPerSec || 0;
    const gainedFromSPS = Math.max(0, sps) * capped;
    const gainedFromAuto = Math.max(0, autoP) * capped * (state.clickPower * globalMultiplier());
    const totalGain = gainedFromSPS + gainedFromAuto;

    if (totalGain > 0){
      state.signal += totalGain;
      state.total += totalGain;
      pushLog("log","SYS",`OFFLINE RECOVERY: +${fmt(totalGain)} SIGNAL.`);
      popupComms("OPS", `While you were away: +${fmt(totalGain)} signal.`);
      touchLocalUpdated();
      saveLocal();
    }

    offlineRecoveryFlag = false;
    setLive("ACTIVE");
  }

  // Heartbeat autosave to keep updatedAtMs fresh
  let heartbeatTimer = null;
  function startHeartbeat(){
    if (heartbeatTimer) clearInterval(heartbeatTimer);
    heartbeatTimer = setInterval(() => {
      if (document.visibilityState !== "visible") return;
      touchLocalUpdated();
      saveLocal();
    }, 25000);
  }
  startHeartbeat();

  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "hidden"){
      saveLocal();
      saveCloud(true);
      setLive("HIDDEN");
    } else {
      startHeartbeat();
      applyOfflineProgress();
      setLive("ACTIVE");
    }
  });

  // ===== Username chip
  function syncUserChip(){
    const chip = $("userChip");
    if (!chip) return;
    const u = (state.profile?.username || "").trim();
    if (u) chip.textContent = "USER: " + u;
    else if (userId) chip.textContent = "USER: " + userId.slice(0,4) + "…" + userId.slice(-4);
    else chip.textContent = "USER: ----";
  }

  $("userChip").onclick = async () => {
    markActive();
    feedback($("userChip"), "light");

    const current = state.profile?.username || "";
    const val = await promptAction({
      title: "SET USERNAME",
      label: "USERNAME",
      initialValue: current,
      placeholder: "corey_01",
      hint: "This name is stored in your save and may appear in comms.",
      okText: "SAVE",
      cancelText: "CANCEL",
      danger: false,
      tag: "PROFILE"
    });
    if (val === null) return;

    const cleaned = normalizeUsername(val);
    if (!isValidUsername(cleaned)){
      popupComms("SYS", "INVALID USERNAME. USE 3–16 CHARACTERS: A–Z, 0–9, _");
      return;
    }

    state.profile.username = cleaned;
    saveLocal();
    await saveCloud(true);
    syncUserChip();
    say("OPS", `Acknowledged, ${cleaned}.`);
  };

  // ===== AI integration (optional)
  const AI_COOLDOWN_MS = 180000;
  function setAiChip(text){ const el = $("aiChip"); if (el) el.textContent = text; }

  $("aiBtn").onclick = (e) => {
    state.aiEnabled = !state.aiEnabled;
    e.currentTarget.textContent = state.aiEnabled ? "DYNAMIC COMMS: ON" : "DYNAMIC COMMS: OFF";
    setAiChip(state.aiEnabled ? "AI: READY" : "AI: DISABLED");
    saveLocal();
    feedback(e.currentTarget, "light");
    markActive();
  };

  function aiReadyNow(){
    if (!state.aiEnabled) return false;
    if (!cloudReady || !supabase) return false;
    if (!isActivelyUsed()) return false;
    const now = Date.now();
    if ((now - (state.lastAiAtMs || 0)) < AI_COOLDOWN_MS) return false;
    return true;
  }

  async function maybeAiComms(eventName, speakerHint){
    if (!aiReadyNow()) return;
    state.lastAiAtMs = Date.now();
    saveLocal();
    setAiChip("AI: THINKING");

    try{
      const payload = {
        event: eventName,
        speaker_hint: speakerHint || "OPS",
        username: (state.profile?.username || "").trim(),
        phase: state.phase,
        build: state.build,
        signal: Math.floor(state.signal),
        total: Math.floor(state.total),
        sps: Math.floor(computeSPS()),
        bandwidth: Number(state.bandwidth.toFixed(2)),
        corruption: Number(state.corruption.toFixed(3))
      };

      const { data, error } = await supabase.functions.invoke("sygn1l-comms", { body: payload });
      if (error) throw error;

      const who = data?.who || speakerHint || "COMMS";
      const msg = data?.text || "…";

      popupComms(who, msg);
      pushLog("comms", who, escapeHtml(msg));

      setAiChip("AI: READY");
    } catch(_){
      setAiChip("AI: OFFLINE");
      pushLog("log","SYS","AI COMMS FAILED. (EDGE FUNCTION OR KEY NOT CONFIGURED)");
    }
  }

  // ===== HUD
  function renderHUD(){
    $("signal").textContent = fmt(state.signal);
    $("sps").textContent = fmt(computeSPS());
    $("bw").textContent = state.bandwidth.toFixed(2) + "×";
    $("buildChip").textContent = "BUILD: " + state.build;
    $("relicChip").textContent = "RELICS: " + state.relics;

    const c = state.corruption;
    $("corrFill").style.width = (c*100).toFixed(1) + "%";
    $("corrText").textContent = (c*100).toFixed(1) + "% (" + corruptionLabel(c) + ")";

    const canPrestige = state.total >= 12000;
    const gainR = prestigeGain();
    const btn = $("prestige");
    btn.disabled = !canPrestige;
    btn.textContent = canPrestige ? `RITE RESET (+${gainR} RELICS)` : "RITE RESET (LOCKED)";

    setSyncChip();
    syncUserChip();
    updateScopeLabel();
  }

  // ===== BUFFS rendering (always runs)
  function renderUpgrades(){
    const root = $("upgrades");
    if (!root) return;
    root.innerHTML = "";

    for (const u of UPG){
      if (u.id === "relicAmp" && (state.relics <= 0 && upgradeLevel("relicAmp") === 0)) continue;

      const unlocked = state.total >= u.unlockAt;
      const lvl = upgradeLevel(u.id);
      const cost = upgradeCost(u);
      const currency = u.currency || "signal";
      const have = currency === "relics" ? state.relics : state.signal;
      const affordable = unlocked && have >= cost;

      const row = document.createElement("div");
      row.className = "up" + (affordable ? " affordable" : "") + (!unlocked ? " locked" : "");

      const meta = document.createElement("div");
      meta.className = "meta";

      const name = document.createElement("div");
      name.className = "name";
      name.textContent = `${u.name} (LV ${lvl})`;

      const desc = document.createElement("div");
      desc.className = "desc";
      desc.textContent = unlocked ? u.desc : `LOCKED UNTIL ${fmt(u.unlockAt)} TOTAL SIGNAL.`;

      const costEl = document.createElement("div");
      costEl.className = "cost";
      costEl.textContent = unlocked ? `COST: ${fmt(cost)} ${currency.toUpperCase()}` : "STATUS: LOCKED";

      meta.appendChild(name);
      meta.appendChild(desc);
      meta.appendChild(costEl);

      const btn = document.createElement("button");
      btn.textContent = unlocked ? (affordable ? "ACQUIRE" : "LOCKED") : "CLASSIFIED";
      btn.disabled = !affordable;

      btn.onclick = async () => {
        if (!affordable) return;
        markActive();
        feedback(btn, "light");

        if (currency === "relics") state.relics -= cost;
        else state.signal -= cost;

        u.buy();
        saveLocal();
        recomputeDerived();
        renderHUD();
        renderUpgrades();
        if (Math.random() < 0.35) maybeBanter("upgrade");
        await saveCloud(false);

        await maybeAiComms("buy_upgrade:" + u.id, u.id === "dark" ? "MOTHERLINE" : "OPS");
      };

      row.appendChild(meta);
      row.appendChild(btn);
      root.appendChild(row);
    }
  }

  // ===== Controls
  $("feedbackBtn").onclick = (e) => {
    feedbackOn = !feedbackOn;
    e.currentTarget.textContent = feedbackOn ? "FEEDBACK: ON" : "FEEDBACK: OFF";
    feedback(e.currentTarget, "light");
    markActive();
  };

  $("ping").addEventListener("click", async (e) => {
    markActive();
    feedback(e.currentTarget, "light");

    gain(state.clickPower * globalMultiplier());
    state.corruption = clamp(state.corruption + 0.0006, 0, 1);

    if (!state.tutorial.firstPing){
      state.tutorial.firstPing = true;
      say("OPS","Good. Baseline ping recorded. Now get DISH CALIBRATION so Signal keeps growing.");
    } else if (Math.random() < 0.18){
      maybeBanter("ping");
    }

    saveLocal();
    recomputeDerived();
    renderHUD();
    renderUpgrades();
    await saveCloud(false);

    if (Math.random() < 0.10) await maybeAiComms("ping_void", "OPS");
  }, { passive:true });

  $("prestige").onclick = async (e) => {
    if (e.currentTarget.disabled) return;
    markActive();
    feedback(e.currentTarget, "strong");

    const gainR = prestigeGain();
    const ok = await confirmAction({
      title: "RITE RESET",
      body: `You will reset Signal, Upgrades, and Phases.<br><br>You will gain <span class="tag">+${gainR} RELICS</span> and keep any <span class="tag">RELIC AMPLIFIER</span> levels.`,
      okText: "EXECUTE",
      cancelText: "CANCEL",
      danger: true,
      tag: "RITE"
    });
    if (!ok) return;

    doPrestige();
    saveLocal();
    renderHUD();
    renderUpgrades();
    await saveCloud(true);
    await maybeAiComms("rite_reset", "MOTHERLINE");
  };

  $("save").onclick = async (e) => {
    markActive();
    feedback(e.currentTarget, "light");
    saveLocal();
    await saveCloud(true);
    pushLog("log","SYS","STATE SAVED.");
    await maybeAiComms("manual_save", "OPS");
  };

  $("wipe").onclick = async () => {
    markActive();
    feedback($("wipe"), "strong");

    const ok = await confirmAction({
      title: "WIPE",
      body: "This will delete your local save and your cloud save (if available).<br><br><span class='tag'>PERMANENT</span> Are you sure?",
      okText: "WIPE",
      cancelText: "CANCEL",
      danger: true,
      tag: "DATA"
    });
    if (!ok) return;

    try{ localStorage.removeItem(LOCAL_KEY); }catch(_){}
    if (cloudReady && supabase && userId){
      try{ await supabase.from("saves").delete().eq("player_id", userId); }catch(_){}
    }
    location.reload();
  };

  // ===== Array Scope (always draws)
  const scope = $("scope");
  const ctx = scope.getContext("2d", { alpha: false });
  let sw = 0, sh = 0, dpr = 1;
  const signature = { cols: [], vel: [], phase: 0 };

  function resizeScope(){
    dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const cssW = scope.clientWidth || 320;
    const cssH = 84;
    scope.style.height = cssH + "px";
    scope.width = Math.floor(cssW * dpr);
    scope.height = Math.floor(cssH * dpr);
    sw = scope.width;
    sh = scope.height;

    const cols = Math.max(120, Math.floor(sw / (2 * dpr)));
    signature.cols = new Array(cols).fill(0);
    signature.vel  = new Array(cols).fill(0);
    signature.phase = 0;
  }
  window.addEventListener("resize", () => {
    resizeScope();
  });

  function lockValue(){
    const bw = state.bandwidth;
    const sps = computeSPS();
    const t = state.total;

    const a = clamp(Math.log10(t + 1) / 5, 0, 1);
    const b = clamp((bw - 1) / 4, 0, 1);
    const c = clamp(Math.log10(sps + 1) / 4, 0, 1);
    const raw = (0.45*a + 0.35*b + 0.20*c);
    const corrupted = raw * (1 - 0.55*state.corruption);
    return clamp(corrupted, 0, 1);
  }
  function updateScopeLabel(){
    $("scopeLabel").textContent = "LOCK: " + Math.round(lockValue() * 100) + "%";
  }

  function rand01(seed){
    seed = (seed ^ 0x6D2B79F5) >>> 0;
    seed = Math.imul(seed ^ (seed >>> 15), 1 | seed);
    seed ^= seed + Math.imul(seed ^ (seed >>> 7), 61 | seed);
    return ((seed ^ (seed >>> 14)) >>> 0) / 4294967296;
  }

  function drawScope(dt, timeMs){
    if (!sw || !sh) return;

    const lk = lockValue();
    const corr = state.corruption;

    ctx.fillStyle = "rgb(0,0,0)";
    ctx.fillRect(0,0,sw,sh);

    const noiseAmt = clamp(0.85 - 0.70*lk + 0.35*corr, 0.15, 0.95);
    const spikeProb = clamp(0.04 + 0.36*lk + 0.10*(state.bandwidth-1)/4, 0.04, 0.70);

    const cols = signature.cols.length;
    signature.phase += dt * (0.6 + 1.8*lk) * (1 + 0.8*corr);

    for (let i=0;i<cols;i++){
      const base = Math.sin(signature.phase + i*0.07) * 0.25;
      const chaos = (rand01((timeMs|0) + i*9973) - 0.5) * (0.45 + 0.9*corr);
      const target = base + chaos;

      const stiffness = 0.08 + 0.22*lk;
      const damping = 0.82 - 0.35*corr;

      signature.vel[i] = signature.vel[i]*damping + (target - signature.cols[i]) * stiffness;
      signature.cols[i] += signature.vel[i];
    }

    const midY = Math.floor(sh * 0.60);
    const px = Math.max(1, Math.floor(dpr));
    const baseG = 190;

    for (let y=0;y<sh;y+=px){
      const lineFade = 0.72 + 0.28*Math.sin((y/sh)*Math.PI);
      for (let x=0;x<sw;x+=px){
        const n = rand01((x*131 + y*977 + (timeMs|0))|0);
        if (n < noiseAmt){
          const v = Math.floor((baseG + 55*n) * lineFade);
          ctx.fillStyle = `rgb(0,${v},0)`;
          ctx.fillRect(x,y,px,px);
        }
      }
    }

    ctx.lineWidth = Math.max(1, 1*dpr);
    ctx.strokeStyle = "rgba(57,255,106,0.85)";
    ctx.beginPath();

    for (let i=0;i<cols;i++){
      const x = Math.floor((i/(cols-1)) * (sw-1));
      const s = signature.cols[i];
      const focus = lk;
      const spike = (rand01((timeMs|0) + i*71) < spikeProb) ? 1 : 0;

      const spikeH = spike * (0.15 + 0.85*focus) * (0.75 + 0.25*Math.abs(s));
      const noiseH = (s * (0.35 + 0.65*(1-focus))) * 0.35;
      const echo = corr > 0.28 ? (0.10 + 0.35*corr) * Math.sin(signature.phase*2 + i*0.12) : 0;

      const y = midY - (spikeH + noiseH + echo) * (sh * 0.70);
      if (i===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    }
    ctx.stroke();

    ctx.globalCompositeOperation = "lighter";
    ctx.strokeStyle = "rgba(57,255,106,0.18)";
    ctx.lineWidth = Math.max(2, 3*dpr);
    ctx.stroke();
    ctx.globalCompositeOperation = "source-over";

    if (corr > 0.45){
      const tears = Math.floor(2 + 8*corr);
      for (let t=0;t<tears;t++){
        const x = Math.floor(rand01((timeMs|0) + t*99991) * sw);
        const w = Math.max(1, Math.floor(dpr));
        ctx.fillStyle = `rgba(255,59,107,${0.04 + 0.08*corr})`;
        ctx.fillRect(x, 0, w, sh);
      }
    }

    ctx.strokeStyle = "rgba(57,255,106,0.18)";
    ctx.lineWidth = Math.max(1, 1*dpr);
    ctx.strokeRect(Math.floor(0.5*dpr), Math.floor(0.5*dpr), sw - Math.floor(1*dpr), sh - Math.floor(1*dpr));
  }

  // ===== Loop timing (fixed, separate lastNow)
  let lastNow = performance.now();

  // ===== Locked buttons fix: periodic refresh
  let upgradesRefreshAcc = 0;
  const UPGRADES_REFRESH_EVERY = 0.25;

  function mainLoop(now){
    const dt = Math.min(0.05, (now - lastNow) / 1000);
    const gap = (now - lastNow) / 1000;
    lastNow = now;

    if (document.visibilityState !== "visible") setLive("HIDDEN");
    else if (offlineRecoveryFlag) setLive("OFFLINE");
    else if (gap > 0.35) setLive("THROTTLED");
    else setLive("ACTIVE");

    recomputeDerived();

    const sps = computeSPS();
    if (sps > 0) gain(sps * dt);

    if (state.autoPingsPerSec > 0){
      const pings = state.autoPingsPerSec * dt;
      gain(pings * (state.clickPower * globalMultiplier()));
    }

    updateCorruption(dt);
    milestoneCheck();
    tutorialCheck();

    if (state.corruption > 0.30 && !state.flags.warnedCorrupt30){
      state.flags.warnedCorrupt30 = true;
      maybeBanter("corruption");
    }

    renderHUD();

    upgradesRefreshAcc += dt;
    if (upgradesRefreshAcc >= UPGRADES_REFRESH_EVERY){
      upgradesRefreshAcc = 0;
      renderUpgrades();
    }

    drawScope(dt, now|0);
    requestAnimationFrame(mainLoop);
  }

  // ===== Startup render
  function bootNarrativeIfEmpty(){
    if ($("log").children.length === 0){
      pushLog("log","SYS","SYGN1L INITIALIZED. SILENCE IS UNPROCESSED DATA.");
      pushLog("comms","OPS","Ping the void so we can establish signal integrity. Then calibrate the dishes.");
      pushLog("comms","DR KESS","We’re scanning because something is already scanning us. We need to know the shape of it.");
    }
  }

  // ===== Init sequence (BUFFS ALWAYS RENDER, even if Supabase dies)
  (async function init(){
    loadLocal();
    recomputeDerived();
    updateObjectiveFallback();
    renderHUD();
    renderUpgrades();
    bootNarrativeIfEmpty();

    // Make sure scope has a real width on mobile: resize after layout
    resizeScope();
    setTimeout(resizeScope, 80);
    setTimeout(resizeScope, 250);

    // Supabase init is optional; do not block the game
    await initSupabase();
    await loadCloudIfNewer();
    setSyncChip();
    syncUserChip();

    applyOfflineProgress();

    // AI chip state
    setAiChip((cloudReady && state.aiEnabled) ? "AI: READY" : (state.aiEnabled ? "AI: OFFLINE" : "AI: DISABLED"));

    pushLog("log","SYS","BOOT COMPLETE. ARRAY STANDING BY.");
    requestAnimationFrame(mainLoop);
  })();

})();
</script>
</body>
</html>
