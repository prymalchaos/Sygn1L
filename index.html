<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<title>SYGN1L</title>

<style>
:root{
  --bg0:#020402; --bg1:#010701;
  --text:#CFFFD6; --muted:#7EDB92;
  --accent:#39FF6A; --danger:#FF3B6B;
  --border:rgba(57,255,106,.25);
  --radius:16px; --shadow:0 10px 22px rgba(0,0,0,.55);
  --glow:0 0 18px rgba(57,255,106,.25);
}

html{ background:var(--bg0); -webkit-text-size-adjust:100%; }
body{
  margin:0;
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  color:var(--text);
  background:
    radial-gradient(900px 600px at 60% 15%, rgba(57,255,106,.10), transparent 60%),
    linear-gradient(180deg, var(--bg1), var(--bg0));
  overflow-y:auto;
  -webkit-overflow-scrolling:touch;
  touch-action:manipulation;
  padding:14px 12px calc(24px + env(safe-area-inset-bottom));
}

body::before{
  content:"";
  position:fixed; inset:0;
  pointer-events:none;
  background: radial-gradient(1200px 900px at 50% 50%, rgba(0,0,0,0) 55%, rgba(0,0,0,.65) 100%);
  z-index:0;
}

.fx{ position:fixed; inset:0; pointer-events:none; z-index:0; }
.fx.scanlines{
  background:repeating-linear-gradient(
    to bottom,
    rgba(57,255,106,.05),
    rgba(57,255,106,.05) 1px,
    rgba(0,0,0,0) 4px,
    rgba(0,0,0,0) 8px
  );
  opacity:.24;
}

.wrap{
  position:relative; z-index:1;
  max-width:860px; margin:0 auto;
  display:grid; gap:18px;
}

.card{
  border:1px solid var(--border);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  background:linear-gradient(180deg, rgba(6,28,12,.62), rgba(3,14,7,.40));
  overflow:hidden;
  position:relative;
}
.card::after{
  content:"";
  position:absolute; inset:-2px;
  pointer-events:none;
  box-shadow: inset 0 0 0 1px rgba(57,255,106,.08), inset 0 0 22px rgba(57,255,106,.06);
}

.pad{ padding:14px; position:relative; }

h1{ margin:0; letter-spacing:.25em; font-size:18px; }
.subtitle{ margin-top:6px; font-size:12px; color:var(--muted); letter-spacing:.06em; }

.stats{
  margin-top:12px;
  display:grid; grid-template-columns:1fr;
  gap:10px;
}
@media(min-width:420px){ .stats{ grid-template-columns:repeat(3,1fr); } }

.stat{
  border:1px solid rgba(57,255,106,.2);
  border-radius:12px;
  padding:10px;
  background:rgba(0,0,0,.30);
}
.stat .k{ font-size:11px; color:var(--muted); letter-spacing:.10em; text-transform:uppercase; }
.stat .v{ margin-top:6px; font-size:18px; overflow-wrap:anywhere; text-shadow:0 0 10px rgba(57,255,106,.10); }

.hd{
  display:flex; justify-content:space-between; align-items:center;
  flex-wrap:wrap; gap:10px;
  padding:12px 14px;
  border-bottom:1px solid rgba(57,255,106,.2);
  background:linear-gradient(180deg, rgba(0,0,0,.22), rgba(0,0,0,0));
  position:relative;
}

.chip{
  border:1px solid rgba(57,255,106,.25);
  border-radius:999px;
  padding:6px 10px;
  font-size:10px; letter-spacing:.14em;
  display:inline-flex; align-items:center; gap:8px;
  background:rgba(0,0,0,.22);
  white-space:nowrap;
}
.dot{ width:8px;height:8px;border-radius:50%; background:var(--accent); box-shadow:var(--glow); }

button{
  font:inherit;
  border-radius:14px;
  border:1px solid rgba(57,255,106,.32);
  background:rgba(57,255,106,.08);
  color:var(--text);
  padding:14px;
  cursor:pointer;
  user-select:none;
  -webkit-tap-highlight-color:transparent;
  transition:.15s;
}
button:hover{ box-shadow:var(--glow); }
button:active{ transform:translateY(1px); }
button:disabled{ opacity:.5; cursor:not-allowed; box-shadow:none; }

.big{
  width:100%;
  font-weight:900;
  letter-spacing:.14em;
  font-size:18px;
  padding:18px 14px;
  background:linear-gradient(180deg, rgba(57,255,106,.16), rgba(57,255,106,.06));
  box-shadow: inset 0 0 0 1px rgba(57,255,106,.10);
}

.grid2{ display:grid; gap:10px; margin-top:12px; }
@media(min-width:420px){ .grid2{ grid-template-columns:1fr 1fr; } }

.muted{ margin-top:10px; font-size:12px; color:var(--muted); line-height:1.45; }

.bar{
  height:10px; border-radius:999px;
  border:1px solid rgba(57,255,106,.22);
  background:rgba(0,0,0,.28);
  overflow:hidden;
}
.fill{
  height:100%;
  width:0%;
  background:linear-gradient(90deg, rgba(57,255,106,.55), rgba(57,255,106,.20));
  box-shadow:0 0 18px rgba(57,255,106,.20);
}
.fill.danger{
  background:linear-gradient(90deg, rgba(255,59,107,.55), rgba(255,59,107,.18));
  box-shadow:0 0 18px rgba(255,59,107,.18);
}

.upgrades{ display:flex; flex-direction:column; gap:12px; }
.up{
  border:1px solid rgba(57,255,106,.2);
  border-radius:14px;
  padding:12px;
  background:rgba(0,0,0,.30);
  display:flex; flex-wrap:wrap;
  gap:12px; align-items:center;
  position:relative;
}
.up.affordable{ box-shadow:var(--glow); }
.up.locked{ opacity:.60; border-style:dashed; }

.up .meta{ flex:1; min-width:220px; }
.up .name{ font-weight:900; letter-spacing:.04em; }
.up .desc,.up .cost{ font-size:12px; margin-top:6px; color:var(--muted); }
.up .cost{ color:rgba(207,255,214,.90); }

.log{
  max-height:320px;
  overflow:auto;
  -webkit-overflow-scrolling:touch;
}
.log p{
  margin:0 0 10px;
  font-size:12px;
  line-height:1.55;
  color:rgba(207,255,214,.88);
}
.tag{
  display:inline-block;
  padding:2px 8px;
  border:1px solid rgba(57,255,106,.22);
  border-radius:999px;
  font-size:10px;
  letter-spacing:.10em;
  color:rgba(207,255,214,.95);
  margin-right:8px;
}

.scopeWrap{
  margin-top:10px;
  border:1px solid rgba(57,255,106,.22);
  border-radius:12px;
  background:rgba(0,0,0,.35);
  overflow:hidden;
}
.scopeTop{
  display:flex;
  justify-content:space-between;
  gap:10px;
  padding:8px 10px;
  border-bottom:1px solid rgba(57,255,106,.14);
  font-size:10px;
  letter-spacing:.12em;
  color:rgba(207,255,214,.92);
}
.scopeMeta{
  color:var(--muted);
  letter-spacing:.10em;
  text-transform:uppercase;
}
canvas#scope{
  display:block;
  width:100%;
  height:84px;
  background:rgba(0,0,0,.25);
}

/* Popup comm bubbles (tap-to-close enabled by JS) */
.popHost{
  position:fixed;
  top:12px;
  left:12px;
  right:12px;
  z-index:999;
  display:flex;
  flex-direction:column;
  gap:10px;
  pointer-events:none;
}
.pop{
  pointer-events:auto;
  max-width:860px;
  margin:0 auto;
  border:1px solid rgba(57,255,106,.25);
  border-radius:14px;
  background:rgba(0,0,0,.72);
  box-shadow:0 10px 26px rgba(0,0,0,.55), 0 0 20px rgba(57,255,106,.15);
  padding:10px 12px;
}
.pop .who{
  font-size:10px;
  letter-spacing:.14em;
  color:rgba(126,219,146,.95);
  margin-bottom:6px;
  text-transform:uppercase;
}
.pop .msg{
  font-size:12px;
  line-height:1.5;
  color:rgba(207,255,214,.94);
}

/* Modal */
.modalHost{
  position:fixed; inset:0;
  background:rgba(0,0,0,.72);
  z-index:2000;
  display:none;
  padding:14px 12px calc(18px + env(safe-area-inset-bottom));
}
.modal{
  max-width:860px;
  margin:0 auto;
  border:1px solid rgba(57,255,106,.28);
  border-radius:16px;
  background:rgba(0,0,0,.78);
  box-shadow:0 12px 30px rgba(0,0,0,.60), 0 0 24px rgba(57,255,106,.12);
  overflow:hidden;
}
.modalHd{
  padding:12px 14px;
  border-bottom:1px solid rgba(57,255,106,.18);
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
}
.modalTitle{
  font-size:11px;
  letter-spacing:.14em;
  color:rgba(207,255,214,.96);
  text-transform:uppercase;
}
.modalBody{
  padding:12px 14px;
  max-height:62vh;
  overflow:auto;
  -webkit-overflow-scrolling:touch;
  font-size:12px;
  line-height:1.55;
  color:rgba(207,255,214,.92);
}
.modalBtns{
  padding:12px 14px;
  border-top:1px solid rgba(57,255,106,.18);
  display:grid;
  gap:10px;
}
@media(min-width:420px){ .modalBtns{ grid-template-columns:1fr 1fr; } }
</style>
</head>

<body>
<div class="fx scanlines"></div>
<div class="popHost" id="popHost"></div>

<!-- Modal -->
<div class="modalHost" id="modalHost">
  <div class="modal">
    <div class="modalHd">
      <div class="modalTitle" id="modalTitle">TRANSMISSION</div>
      <div class="chip">TAP OUTSIDE TO CLOSE</div>
    </div>
    <div class="modalBody" id="modalBody"></div>
    <div class="modalBtns">
      <button id="modalOk">OK</button>
      <button id="modalCancel">CLOSE</button>
    </div>
  </div>
</div>

<div class="wrap">

  <header class="card">
    <div class="pad">
      <h1>SYGN1L</h1>
      <div class="subtitle">THE ARRAY LISTENS. THE VOID REPLIES IN ARITHMETIC.</div>

      <div class="stats">
        <div class="stat"><div class="k">SIGNAL</div><div class="v" id="signal">0</div></div>
        <div class="stat"><div class="k">SIGNAL/SEC</div><div class="v" id="sps">0</div></div>
        <div class="stat"><div class="k">BANDWIDTH</div><div class="v" id="bw">1.00×</div></div>
      </div>

      <div class="scopeWrap">
        <div class="scopeTop">
          <div>ARRAY SCOPE</div>
          <div class="scopeMeta" id="scopeLabel">LOCK: 0%</div>
        </div>
        <canvas id="scope"></canvas>
      </div>

      <div style="height:10px"></div>

      <!-- ✅ Corruption bar exists here -->
      <div class="stat">
        <div class="k">CORRUPTION</div>
        <div class="bar"><div class="fill danger" id="corrFill"></div></div>
        <div class="muted" id="corrText">0% (DORMANT)</div>
      </div>
    </div>
  </header>

  <section class="card">
    <div class="hd">
      <div>
        <span class="chip"><span class="dot"></span><span id="phase">PHASE I</span></span>
        <span class="chip" id="status">ARRAY: STABLE</span>
        <span class="chip" id="buildChip">BUILD: 1</span>
        <span class="chip" id="relicChip">RELICS: 0</span>
      </div>
      <div>
        <span class="chip" id="syncChip">SYNC: LOCAL</span>
        <!-- ✅ Clickable username chip -->
        <span class="chip" id="userChip" title="Tap to edit username">USER: Operator</span>
        <!-- ✅ Optional but supported -->
        <span class="chip" id="liveChip">LIVE: IDLE</span>
      </div>
    </div>

    <div class="pad">
      <button class="big" id="ping">PING THE VOID</button>

      <div class="grid2">
        <button id="briefing">BRIEFING</button>
        <button id="save">SAVE</button>
      </div>

      <div class="grid2">
        <button id="wipe">WIPE</button>
        <button id="prestige" disabled>RITE RESET (LOCKED)</button>
      </div>

      <div class="muted" id="objective">
        OBJECTIVE: START WITH DISH CALIBRATION. REACH 100 TOTAL SIGNAL TO UNLOCK DEEP SCAN.
      </div>
    </div>
  </section>

  <section class="card">
    <div class="hd">
      <div>BUFFS</div>
      <div class="muted">UNLOCKED BY MILESTONES. AVAILABLE BUFFS GLOW.</div>
    </div>
    <div class="pad">
      <!-- ✅ Required -->
      <div class="upgrades" id="upgrades"></div>
    </div>
  </section>

  <section class="card">
    <div class="hd">
      <div>DECODER</div>
      <div class="muted">PHASE V UNLOCKS ENGRAM DECRYPTION</div>
    </div>
    <div class="pad">
      <!-- ✅ Required -->
      <div id="decoder"></div>
    </div>
  </section>

  <section class="card">
    <div class="hd">
      <div>COMMUNICATIONS</div>
      <div class="muted">TAP A LINE TO DISMISS</div>
    </div>
    <div class="pad">
      <div class="log" id="comms"></div>
    </div>
  </section>

  <section class="card">
    <div class="hd">
      <div>TRANSMISSION LOG</div>
      <div class="muted">MILESTONES REVEAL CONTEXT</div>
    </div>
    <div class="pad">
      <div class="log" id="log"></div>
    </div>
  </section>

</div>

<!-- Supabase lib -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<!-- Part B JS goes below -->
(() => {
  const $ = (id) => document.getElementById(id);

  // Prevent double-tap zoom on buttons
  document.addEventListener("dblclick", (e) => {
    if (e.target && e.target.closest("button")) e.preventDefault();
  }, { passive:false });

  // ===== Supabase config (your project)
  const SUPABASE_URL = "https://qwrvlhdouicfyypxjffn.supabase.co";
  const SUPABASE_ANON_KEY = "sb_publishable_uBQsnY94g__2VzSm4Z9Yvg_mq32-ABR";
  const supabase = window.supabase?.createClient
    ? window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY)
    : null;

  // ===== Constants
  const FINAL_MESSAGE = "Greetings! This is a warning. Prepare for invasion. They are coming";
  const PHASE2 = 500, PHASE3 = 1800, PHASE4 = 9000, PHASE5 = 15000;
  const RITE_RESET_THRESHOLD = 12000;

  // ===== Utils
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  function fmt(n){
    n = Number(n);
    if (!Number.isFinite(n)) return "0";
    if (n < 1000) return n.toFixed(0);
    const units = ["K","M","B","T","Qa","Qi"];
    let u = -1;
    while (n >= 1000 && u < units.length-1){ n/=1000; u++; }
    return n.toFixed(n<10?2:n<100?1:0)+units[u];
  }
  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }
  function corruptionLabel(c){
    if (c < 0.10) return "DORMANT";
    if (c < 0.30) return "WHISPERING";
    if (c < 0.60) return "INCIDENT";
    if (c < 0.85) return "BREACH";
    return "OVERRUN";
  }

  // ===== Activity gating (for “LIVE” chip + future AI)
  let lastUserActionAt = 0;
  function markActive(){ lastUserActionAt = Date.now(); }
  window.addEventListener("pointerdown", markActive, { passive:true });
  window.addEventListener("keydown", markActive, { passive:true });
  function isActivelyUsed(){ return (Date.now() - lastUserActionAt) <= 20000; }

  // ===== Popup comms (tap to close)
  function popupComms(who, msg){
    const host = $("popHost");
    if (!host) return;
    const box = document.createElement("div");
    box.className = "pop";
    box.innerHTML = `<div class="who">${escapeHtml(who)}</div><div class="msg">${escapeHtml(msg)}</div>`;
    box.addEventListener("click", () => box.remove());
    host.prepend(box);
  }

  function pushLog(elId, who, msg){
    const root = $(elId);
    if (!root) return;
    const p = document.createElement("p");
    p.innerHTML = `<span class="tag">${escapeHtml(who)}</span>${escapeHtml(msg)}`;
    p.style.cursor = "pointer";
    p.title = "Tap to dismiss";
    p.addEventListener("click", ()=>p.remove());
    root.prepend(p);
  }

  // ===== Modal
  const modalHost = $("modalHost");
  const modalTitle = $("modalTitle");
  const modalBody = $("modalBody");
  const modalOk = $("modalOk");
  const modalCancel = $("modalCancel");

  function openModal(title, html, opts={}){
    if (!modalHost) return Promise.resolve(false);

    modalTitle.textContent = title || "TRANSMISSION";
    modalBody.innerHTML = html || "";
    modalOk.textContent = opts.okText || "OK";
    modalCancel.textContent = opts.cancelText || "CLOSE";
    modalCancel.style.display = opts.hideCancel ? "none" : "";
    modalHost.style.display = "block";

    requestAnimationFrame(()=>{ modalBody.scrollTop = 0; });

    return new Promise((resolve)=>{
      const onOk = ()=>cleanup(true);
      const onCancel = ()=>cleanup(false);
      const onBackdrop = (e)=>{ if (e.target === modalHost) cleanup(false); };

      function cleanup(v){
        modalOk.removeEventListener("click", onOk);
        modalCancel.removeEventListener("click", onCancel);
        modalHost.removeEventListener("click", onBackdrop);
        modalHost.style.display = "none";
        resolve(v);
      }

      modalOk.addEventListener("click", onOk);
      modalCancel.addEventListener("click", onCancel);
      modalHost.addEventListener("click", onBackdrop);
    });
  }

  async function confirmAction(title, message, okText){
    return await openModal(
      title,
      `<div style="white-space:pre-wrap">${escapeHtml(message)}</div>`,
      { okText: okText || "CONFIRM", cancelText:"CANCEL" }
    );
  }

  // ===== State
  const state = {
    username: "Operator",
    build: 1,
    relics: 0,

    signal: 0,
    total: 0,

    baseSPS: 0,
    clickPower: 1,
    bandwidth: 1.0,
    autoPingsPerSec: 0,

    corruption: 0,
    phase: 1,

    // IMPORTANT: start at 0 so blank boot can never “beat” cloud
    updatedAtMs: 0,
    lastTickMs: Date.now(),

    upgrades: {
      dish: 0, scan: 0, probes: 0, tuning: 0,
      autopinger: 0, echo: 0, lattice: 0, dark: 0,
      firewall: 0, purifier: 0, deadband: 0, decoderRig: 0,
      relicAmp: 0
    },

    archive: {
      engramsSolved: 0,
      engramsTotal: FINAL_MESSAGE.length,
      hasCipherKey: false,
      awaitingRiteReset: false,
      finalMessageRevealed: false,
      scrambleSeed: (Math.floor(Math.random()*1e9)>>>0)
    }
  };
  window.SYGN1L_STATE = state;

  function touchUpdated(){ state.updatedAtMs = Date.now(); }

  // ===== Prestige gain (shows on button)
  function prestigeGain(){
    const over = Math.max(0, state.total - RITE_RESET_THRESHOLD);
    const base = 1;
    const extra = Math.floor(Math.sqrt(over / 6000));
    return base + extra;
  }

  // ===== Upgrades
  const lv = (id)=>state.upgrades[id]||0;

  const UPG = [
    { id:"dish", name:"DISH CALIBRATION", unlockAt:0, baseCost:10, costMult:1.18,
      desc:"+1 SIGNAL/SEC PER LEVEL.", buy(){ state.upgrades.dish++; } },

    { id:"scan", name:"DEEP SCAN", unlockAt:100, baseCost:50, costMult:1.25,
      desc:"+10% BASE BANDWIDTH PER LEVEL.", buy(){ state.upgrades.scan++; } },

    { id:"probes", name:"PROBE SWARM", unlockAt:120, baseCost:80, costMult:1.22,
      desc:"+1 CLICK POWER PER LEVEL.", buy(){ state.upgrades.probes++; } },

    { id:"tuning", name:"HARMONIC TUNING", unlockAt:240, baseCost:140, costMult:1.27,
      desc:"+0.35 SPS +1% BANDWIDTH PER LEVEL.", buy(){ state.upgrades.tuning++; } },

    { id:"autopinger", name:"AUTO-PINGER ROUTINE", unlockAt:600, baseCost:520, costMult:1.30,
      desc:"ADDS AUTO-PINGS/SEC. SCALES WITH PROBES.", buy(){ state.upgrades.autopinger++; } },

    { id:"echo", name:"ECHO INTEGRATOR", unlockAt:1800, baseCost:1400, costMult:1.35,
      desc:"BANDWIDTH BONUS SCALES WITH LOG(SIGNAL).", buy(){ state.upgrades.echo++; } },

    { id:"lattice", name:"HARMONIC LATTICE", unlockAt:3500, baseCost:3200, costMult:1.38,
      desc:"SPS MULT SCALES WITH CORRUPTION.", buy(){ state.upgrades.lattice++; } },

    { id:"dark", name:"DARK LISTENING", unlockAt:7000, baseCost:9000, costMult:1.45,
      desc:"IF CORRUPTION>30%: GAINS × (1 + 0.12*LV).", buy(){ state.upgrades.dark++; } },

    { id:"firewall", name:"FIREWALL SIGIL", unlockAt:9000, baseCost:8500, costMult:1.42,
      desc:"SLOWS CORRUPTION GROWTH PER LEVEL.", buy(){ state.upgrades.firewall++; } },

    { id:"purifier", name:"SIGNAL PURIFIER", unlockAt:11000, baseCost:12000, costMult:1.48,
      desc:"PASSIVELY REDUCES CORRUPTION OVER TIME.", buy(){ state.upgrades.purifier++; } },

    { id:"deadband", name:"DEADBAND AMPLIFIER", unlockAt:13000, baseCost:16000, costMult:1.52,
      desc:"+BANDWIDTH BUT ADDS CORRUPTION PRESSURE.", buy(){ state.upgrades.deadband++; } },

    { id:"decoderRig", name:"DECODER RIG", unlockAt:15000, baseCost:24000, costMult:1.60,
      desc:"REDUCES ENGRAM COSTS BY 6% PER LEVEL.", buy(){ state.upgrades.decoderRig++; } }
  ];

  function upgradeCost(u){
    return Math.floor(u.baseCost * Math.pow(u.costMult, lv(u.id)));
  }

  // ===== Derived math
  function computeBaseSPS(){ return lv("dish")*1.0 + lv("tuning")*0.35; }
  function computeClickPower(){ return 1 + lv("probes")*1.0; }
  function computeBaseBandwidth(){
    let bw = 1.0;
    bw *= Math.pow(1.10, lv("scan"));
    bw *= Math.pow(1.01, lv("tuning"));
    bw *= (1 + 0.05 * lv("deadband"));
    return bw;
  }
  function computeEchoMultiplier(){
    const e = lv("echo");
    return e<=0 ? 1 : (1 + 0.03*e*Math.log10(state.signal+1));
  }
  function computeRelicMultiplier(){ return 1 + 0.08*lv("relicAmp"); }
  function computeLatticeMultiplier(){
    const l = lv("lattice");
    if (l<=0) return 1;
    const term = Math.sqrt(clamp(state.corruption,0,1)*10);
    return 1 + 0.06*l*term;
  }
  function computeDarkMultiplier(){
    const d = lv("dark");
    return d<=0 ? 1 : (state.corruption > 0.30 ? (1 + 0.12*d) : 1);
  }
  function computeAutoPingsPerSec(){
    const a = lv("autopinger");
    if (a<=0) return 0;
    const probeFactor = 1 + lv("probes")*0.15;
    return a * 0.65 * probeFactor;
  }
  function recompute(){
    state.baseSPS = computeBaseSPS();
    state.clickPower = computeClickPower();
    state.bandwidth = computeBaseBandwidth() * computeEchoMultiplier() * computeRelicMultiplier();
    state.autoPingsPerSec = computeAutoPingsPerSec();
  }
  const sps = ()=> state.baseSPS * state.bandwidth * computeLatticeMultiplier() * computeDarkMultiplier();
  const globalMult = ()=> state.bandwidth * computeLatticeMultiplier() * computeDarkMultiplier();

  // ===== Corruption
  function updateCorruption(dt){
    const creep = 0.0000025 * Math.log10(state.total + 10);
    const tech  = (lv("echo")*0.0000015) + (lv("lattice")*0.0000018) + (lv("dark")*0.0000022);
    const invite= 0.0000010;

    const firewall = 1 - clamp(0.06*lv("firewall"), 0, 0.55);
    const deadband = 1 + clamp(0.05*lv("deadband"), 0, 0.60);
    const phaseAmp = (state.phase >= 4) ? 1.35 : 1.0;

    state.corruption = clamp(state.corruption + (creep+tech+invite) * firewall * deadband * phaseAmp * dt, 0, 1);

    const pur = lv("purifier");
    if (pur > 0){
      state.corruption = clamp(state.corruption - (0.000010 * pur) * dt, 0, 1);
    }
  }

  // ===== Phase logic
  function phaseCheck(){
    const p = state.total >= PHASE5 ? 5 :
              state.total >= PHASE4 ? 4 :
              state.total >= PHASE3 ? 3 :
              state.total >= PHASE2 ? 2 : 1;
    state.phase = Math.max(state.phase, p);
  }

  // ===== Decoder
  function engramCost(){
    const n = state.archive.engramsSolved;
    const rigDiscount = Math.pow(0.94, lv("decoderRig"));
    const base = 1200;
    const ramp = Math.pow(1.14, n);
    return Math.floor(base * ramp * rigDiscount);
  }

  function scrambleDisplay(seed, revealedCount){
    const text = FINAL_MESSAGE;
    const len = text.length;
    let s = (seed >>> 0) || 1;
    const rnd = () => {
      s ^= s << 13; s >>>= 0;
      s ^= s >>> 17; s >>>= 0;
      s ^= s << 5;  s >>>= 0;
      return (s >>> 0) / 4294967296;
    };
    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!?.,:;-' ";
    const out = [];
    for (let i=0;i<len;i++){
      if (i < revealedCount) out.push(text[i]);
      else out.push(alphabet[Math.floor(rnd()*alphabet.length)]);
    }
    return out.join("");
  }

  function renderDecoder(){
    const root = $("decoder");
    if (!root) return;

    if (state.phase < 5){
      root.innerHTML = `<div class="muted">STATUS: LOCKED. REACH PHASE V (15,000 TOTAL SIGNAL).</div>`;
      return;
    }

    const solved = state.archive.engramsSolved;
    const total = state.archive.engramsTotal;
    const done = solved >= total;

    const scrambled = scrambleDisplay(state.archive.scrambleSeed, solved);
    const price = engramCost();
    const canBuy = state.signal >= price && !done;

    root.innerHTML = `
      <div class="muted">STATUS: ${done ? "CIPHER KEY ACQUIRED" : "DECRYPTING"}</div>
      <div style="margin-top:10px;border:1px solid rgba(57,255,106,.25);border-radius:12px;padding:10px;background:rgba(0,0,0,.30)">
        <div style="font-size:10px;letter-spacing:.12em;color:var(--muted);margin-bottom:6px">INTERCEPTED STRING</div>
        <div style="white-space:pre-wrap;word-break:break-word;font-size:12px;line-height:1.55">${escapeHtml(scrambled)}</div>
      </div>
      <div class="muted" style="margin-top:10px">ENGRAMS: <b style="color:var(--text)">${solved}</b> / ${total}</div>
      <div style="margin-top:12px">
        <button id="decryptBtn" ${canBuy ? "" : "disabled"}>
          ${done ? "DECRYPT COMPLETE" : (canBuy ? `DECRYPT ENGRAM (COST ${fmt(price)})` : `INSUFFICIENT SIGNAL (COST ${fmt(price)})`)}
        </button>
      </div>
      ${state.archive.awaitingRiteReset && state.archive.hasCipherKey && !state.archive.finalMessageRevealed
        ? `<div class="muted" style="margin-top:10px">CIPHER KEY READY. RITE RESET REQUIRED TO APPLY.</div>`
        : ``}
    `;

    const btn = $("decryptBtn");
    if (btn){
      btn.onclick = () => {
        markActive();
        const priceNow = engramCost();
        if (state.signal < priceNow) return;

        state.signal -= priceNow;
        state.archive.engramsSolved++;

        if (state.archive.engramsSolved >= state.archive.engramsTotal){
          state.archive.engramsSolved = state.archive.engramsTotal;
          state.archive.hasCipherKey = true;
          state.archive.awaitingRiteReset = true;
          popupComms("DR KESS", `${state.username}, final engram is a key. We need a Rite Reset to apply it.`);
          pushLog("comms","DR KESS", `${state.username}, final engram is a key. We need a Rite Reset to apply it.`);
        }

        touchUpdated();
        renderHUD();
        renderUpgrades();
        renderDecoder();
        saveLocal();
        saveCloud(false);
      };
    }
  }

  // ===== Rite Reset
  function doRiteReset(){
    const gainR = prestigeGain();
    state.relics += gainR;
    state.build += 1;

    // Keep archive + username always
    const keepArchive = JSON.parse(JSON.stringify(state.archive));
    const keepName = state.username;

    state.signal = 0;
    state.total = 0;
    state.corruption = Math.max(0, state.corruption * 0.25);
    state.phase = 1;

    for (const k in state.upgrades) state.upgrades[k] = 0;

    state.archive = keepArchive;
    state.username = keepName;

    // Apply cipher key on Rite Reset (this is the “unscramble” moment)
    if (state.archive.awaitingRiteReset && state.archive.hasCipherKey && !state.archive.finalMessageRevealed){
      state.archive.awaitingRiteReset = false;
      state.archive.finalMessageRevealed = true;
      popupComms("DECRYPT", FINAL_MESSAGE);
      pushLog("comms","DECRYPT", FINAL_MESSAGE);
      pushLog("log","SYS","CIPHER KEY APPLIED. STRING UNSCRAMBLED.");
    }
  }

  // ===== Objective
  function updateObjective(){
    const o = $("objective");
    if (!o) return;

    if (state.total < 100) o.textContent = "OBJECTIVE: BUY DISH CALIBRATION. REACH 100 TOTAL SIGNAL FOR DEEP SCAN.";
    else if (state.total < 600) o.textContent = "OBJECTIVE: UNLOCK AUTO-PINGER AT 600 TOTAL SIGNAL. PUSH SIGNAL/SEC.";
    else if (state.total < 3500) o.textContent = "OBJECTIVE: PREPARE HARMONIC LATTICE AT 3500 TOTAL SIGNAL. WATCH CORRUPTION.";
    else if (state.total < RITE_RESET_THRESHOLD) o.textContent = "OBJECTIVE: RITE RESET UNLOCKS AT 12,000 TOTAL SIGNAL. RELICS PERSIST.";
    else if (state.total < PHASE5) o.textContent = "OBJECTIVE: PHASE V AT 15,000 TOTAL SIGNAL UNLOCKS THE DECODER.";
    else o.textContent = "OBJECTIVE: DECRYPT ENGRAMS. APPLY CIPHER KEY VIA RITE RESET.";
  }

  // ===== HUD render (includes corruption + Rite Reset (+X relics))
  function renderHUD(){
    if ($("signal")) $("signal").textContent = fmt(state.signal);
    if ($("sps")) $("sps").textContent = fmt(sps());
    if ($("bw")) $("bw").textContent = state.bandwidth.toFixed(2) + "×";

    if ($("buildChip")) $("buildChip").textContent = "BUILD: " + state.build;
    if ($("relicChip")) $("relicChip").textContent = "RELICS: " + state.relics;

    if ($("phase")){
      $("phase").textContent =
        state.phase===1 ? "PHASE I" :
        state.phase===2 ? "PHASE II" :
        state.phase===3 ? "PHASE III" :
        state.phase===4 ? "PHASE IV" : "PHASE V";
    }

    if ($("userChip")) $("userChip").textContent = "USER: " + state.username;

    const live = $("liveChip");
    if (live){
      live.textContent = isActivelyUsed() ? "LIVE: ACTIVE" : "LIVE: IDLE";
      live.style.opacity = isActivelyUsed() ? "1" : "0.65";
    }

    // Corruption bar
    const cf = $("corrFill");
    const ct = $("corrText");
    if (cf) cf.style.width = (clamp(state.corruption,0,1)*100).toFixed(1) + "%";
    if (ct){
      const c = clamp(state.corruption,0,1);
      ct.textContent = (c*100).toFixed(1) + "% (" + corruptionLabel(c) + ")";
    }

    // Status chip (optional)
    if ($("status")){
      $("status").textContent =
        state.phase<=1 ? "ARRAY: STABLE" :
        state.phase===2 ? "ARRAY: DRIFT" :
        state.phase===3 ? "ARRAY: ACTIVE" :
        state.phase===4 ? "ARRAY: FRACTURE" : "ARRAY: OPEN";
    }

    // Rite Reset button label
    const btn = $("prestige");
    if (btn){
      const canReset = state.total >= RITE_RESET_THRESHOLD;
      const gainR = prestigeGain();
      btn.disabled = !canReset;
      btn.textContent = canReset ? `RITE RESET (+${gainR} RELICS)` : "RITE RESET (LOCKED)";
    }

    updateObjective();
    updateScopeLabel();
  }

  // ===== Locked button fix: render upgrades often + recompute affordability on click
  function renderUpgrades(){
    const root = $("upgrades");
    if (!root) return;
    root.innerHTML = "";

    for (const u of UPG){
      const unlocked = state.total >= u.unlockAt;
      const lvlNow = lv(u.id);
      const price = upgradeCost(u);
      const affordable = unlocked && state.signal >= price;

      const row = document.createElement("div");
      row.className = "up" + (affordable ? " affordable" : "") + (!unlocked ? " locked" : "");

      const meta = document.createElement("div");
      meta.className = "meta";
      meta.innerHTML = `
        <div class="name">${escapeHtml(u.name)} (LV ${lvlNow})</div>
        <div class="desc">${escapeHtml(unlocked ? u.desc : `LOCKED UNTIL ${fmt(u.unlockAt)} TOTAL SIGNAL.`)}</div>
        <div class="cost">${unlocked ? `COST: ${fmt(price)} SIGNAL` : "STATUS: LOCKED"}</div>
      `;

      const btn = document.createElement("button");
      btn.textContent = unlocked ? (affordable ? "ACQUIRE" : "LOCKED") : "CLASSIFIED";
      btn.disabled = !affordable;

      btn.onclick = () => {
        markActive();

        // IMPORTANT: re-evaluate now (prevents “stuck locked until refresh”)
        const unlockedNow = state.total >= u.unlockAt;
        const priceNow = upgradeCost(u);
        const canBuyNow = unlockedNow && state.signal >= priceNow;
        if (!canBuyNow) return;

        state.signal -= priceNow;
        u.buy();

        touchUpdated();
        recompute();
        renderHUD();
        renderUpgrades();
        renderDecoder();

        saveLocal();
        saveCloud(false);
      };

      row.appendChild(meta);
      row.appendChild(btn);
      root.appendChild(row);
    }
  }

  // ===== Scope visualiser
  const scope = $("scope");
  const scopeLabel = $("scopeLabel");
  let ctx = null, sw=0, sh=0, dpr=1;
  let sigPhase = 0;

  function resizeScope(){
    if (!scope) return;
    ctx = scope.getContext("2d", { alpha:false });
    dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const cssW = scope.clientWidth || 320;
    const cssH = 84;
    scope.width = Math.floor(cssW * dpr);
    scope.height = Math.floor(cssH * dpr);
    sw = scope.width;
    sh = scope.height;
  }
  window.addEventListener("resize", resizeScope);

  function lockValue(){
    const a = clamp(Math.log10(state.total + 1) / 5, 0, 1);
    const b = clamp((state.bandwidth - 1) / 4, 0, 1);
    const c = clamp(Math.log10(sps() + 1) / 4, 0, 1);
    const raw = (0.45*a + 0.35*b + 0.20*c);
    const corrupted = raw * (1 - 0.55*state.corruption);
    return clamp(corrupted, 0, 1);
  }
  function updateScopeLabel(){
    if (!scopeLabel) return;
    scopeLabel.textContent = "LOCK: " + Math.round(lockValue()*100) + "%";
  }

  function drawScope(dt){
    if (!ctx || !sw || !sh) return;

    const lk = lockValue();
    const corr = state.corruption;

    ctx.fillStyle = "rgb(0,0,0)";
    ctx.fillRect(0,0,sw,sh);

    const noiseAmt = clamp(0.85 - 0.70*lk + 0.35*corr, 0.15, 0.95);
    const spikeProb = clamp(0.04 + 0.36*lk, 0.04, 0.70);
    const px = Math.max(1, Math.floor(dpr));

    for (let y=0;y<sh;y+=px){
      for (let x=0;x<sw;x+=px){
        if (Math.random() < noiseAmt){
          const g = Math.floor(150 + 90*Math.random());
          ctx.fillStyle = `rgb(0,${g},0)`;
          ctx.fillRect(x,y,px,px);
        }
      }
    }

    sigPhase += dt * (0.6 + 1.8*lk) * (1 + 0.8*corr);
    const midY = Math.floor(sh*0.60);

    ctx.strokeStyle = "rgba(57,255,106,0.85)";
    ctx.lineWidth = Math.max(1, 1*dpr);
    ctx.beginPath();
    for (let i=0;i<120;i++){
      const x = (i/119)*(sw-1);
      const spike = (Math.random() < spikeProb) ? (0.2 + 0.8*Math.random()) : 0;
      const wave = Math.sin(sigPhase + i*0.12) * (0.10 + 0.15*(1-lk));
      const tear = corr > 0.45 ? Math.sin(sigPhase*4 + i*0.22) * (0.06 + 0.10*corr) : 0;
      const y = midY - (spike + wave + tear) * (sh * 0.70);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
  }

  // ===== Offline progress
  function applyOfflineProgress(){
    const now = Date.now();
    const then = state.lastTickMs || state.updatedAtMs || now;
    const dtMs = clamp(now - then, 0, 1000*60*60*12);
    const dt = dtMs/1000;
    if (dt < 10) return;

    recompute();
    const rate = sps();

    // cap: 20min base + extra by phase and purifier
    const cap = 60*20 + (state.phase*60*10) + (lv("purifier")*60*10);
    const effective = Math.min(dt, cap);

    const gained = rate * effective;
    state.signal += gained;
    state.total += gained;

    updateCorruption(effective * 0.6);

    pushLog("log","SYS",`OFFLINE RECOVERY: +${fmt(gained)} SIGNAL (${Math.floor(effective)}s simulated)`);
  }

  // ===== Gains
  function gain(x){ state.signal += x; state.total += x; }

  // ===== Saves (Local + Cloud) with wipe-proof merge
  const LOCAL_KEYS = [
    "sygn1l_save_vA",
    "sygn1l_save_v3",
    "sygn1l_cloudsave_v3",
    "sygn1l_save",
  ];

  let userId = null;
  let cloudReady = false;
  let lastCloudSaveAt = 0;

  function normalizeLoadedState(data){
    for (const k in data){
      if (data[k] && typeof data[k] === "object" && state[k] && typeof state[k] === "object"){
        Object.assign(state[k], data[k]);
      } else {
        state[k] = data[k];
      }
    }

    state.upgrades = Object.assign({
      dish:0, scan:0, probes:0, tuning:0,
      autopinger:0, echo:0, lattice:0, dark:0,
      firewall:0, purifier:0, deadband:0, decoderRig:0,
      relicAmp:0
    }, state.upgrades || {});

    state.archive = Object.assign({
      engramsSolved:0,
      engramsTotal: FINAL_MESSAGE.length,
      hasCipherKey:false,
      awaitingRiteReset:false,
      finalMessageRevealed:false,
      scrambleSeed:(Math.floor(Math.random()*1e9)>>>0)
    }, state.archive || {});

    // Make sure timestamps exist
    state.updatedAtMs = Number(state.updatedAtMs || 0);
    state.lastTickMs = Number(state.lastTickMs || Date.now());
  }

  function loadFromKey(key){
    const raw = localStorage.getItem(key);
    if (!raw) return null;
    try { return JSON.parse(raw); } catch { return null; }
  }

  function saveLocal(){
    touchUpdated();
    localStorage.setItem(LOCAL_KEYS[0], JSON.stringify(state));
    if ($("syncChip")) $("syncChip").textContent = cloudReady ? "SYNC: CLOUD+LOCAL" : "SYNC: LOCAL";
  }

  function loadLocal(){
    let best = null;
    let bestUpdated = -1;

    for (const key of LOCAL_KEYS){
      const data = loadFromKey(key);
      if (!data) continue;
      const t = Number(data.updatedAtMs || 0);
      if (t > bestUpdated){
        bestUpdated = t;
        best = data;
      }
    }

    if (!best) return false;

    normalizeLoadedState(best);
    // migrate forward
    localStorage.setItem(LOCAL_KEYS[0], JSON.stringify(state));
    return true;
  }

  async function ensureSession(){
    if (!supabase) return null;
    try{
      let { data: { session } } = await supabase.auth.getSession();
      if (!session){
        const { data, error } = await supabase.auth.signInAnonymously();
        if (error) throw error;
        session = data.session;
      }
      userId = session.user.id;
      cloudReady = true;
      if ($("syncChip")) $("syncChip").textContent = "SYNC: CLOUD";
      return userId;
    } catch {
      cloudReady = false;
      if ($("syncChip")) $("syncChip").textContent = "SYNC: OFFLINE";
      return null;
    }
  }

  async function loadCloud(){
    if (!supabase || !cloudReady || !userId) return null;
    try{
      const { data, error } = await supabase
        .from("saves")
        .select("state, updated_at")
        .eq("player_id", userId)
        .maybeSingle();
      if (error) throw error;
      if (!data?.state) return null;

      const cloudState = data.state;
      const cloudUpdatedMs = cloudState.updatedAtMs || (data.updated_at ? Date.parse(data.updated_at) : 0);
      return { cloudState, cloudUpdatedMs };
    } catch {
      cloudReady = false;
      if ($("syncChip")) $("syncChip").textContent = "SYNC: OFFLINE";
      return null;
    }
  }

  async function saveCloud(force=false){
    if (!supabase || !cloudReady || !userId) return false;

    const now = Date.now();
    if (!force && (now - lastCloudSaveAt) < 45000) return false;
    lastCloudSaveAt = now;

    try{
      touchUpdated();
      const payload = {
        player_id: userId,
        updated_at: new Date().toISOString(),
        state: JSON.parse(JSON.stringify(state))
      };
      const { error } = await supabase.from("saves").upsert(payload);
      if (error) throw error;
      if ($("syncChip")) $("syncChip").textContent = "SYNC: CLOUD+LOCAL";
      return true;
    } catch {
      cloudReady = false;
      if ($("syncChip")) $("syncChip").textContent = "SYNC: OFFLINE";
      return false;
    }
  }

  async function initSaves(){
    const localLoaded = loadLocal();

    // If local didn't load, ensure blank can't appear “newer” than cloud
    if (!localLoaded) state.updatedAtMs = 0;

    await ensureSession();
    const cloud = await loadCloud();

    if (cloud?.cloudState){
      const localUpdated = Number(state.updatedAtMs || 0);
      const cloudUpdated = Number(cloud.cloudUpdatedMs || 0);

      if (cloudUpdated > localUpdated){
        normalizeLoadedState(cloud.cloudState);
        pushLog("log","SYS","CLOUD SAVE LOADED (NEWER THAN LOCAL).");
        localStorage.setItem(LOCAL_KEYS[0], JSON.stringify(state));
      } else {
        // Only push local if it actually loaded (prevents blank overwrite)
        if (localLoaded && cloudReady){
          await saveCloud(true);
          pushLog("log","SYS","LOCAL SAVE PUSHED TO CLOUD (NEWER).");
        } else {
          pushLog("log","SYS","CLOUD PRESENT; LOCAL NOT LOADED. SKIPPING CLOUD OVERWRITE.");
        }
      }
    } else {
      if (localLoaded) pushLog("log","SYS","LOCAL SAVE LOADED.");
      else {
        pushLog("log","SYS","SYGN1L INITIALIZED. SILENCE IS UNPROCESSED DATA.");
        pushLog("comms","OPS","Ping the Void so we can establish signal integrity.");
        pushLog("comms","DR KESS","We need you to calibrate the dishes. That’s how the snowball starts.");
      }
    }
  }

  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "hidden"){
      saveLocal();
      saveCloud(true);
    }
  });

  // ===== Username edit
  async function editUsername(){
    const html = `
      <div class="muted" style="margin:0 0 10px">Set a callsign. Used in comms.</div>
      <input id="nameInput" maxlength="18"
        value="${escapeHtml(state.username === "Operator" ? "" : state.username)}"
        placeholder="e.g. Corey"
        style="width:100%;box-sizing:border-box;padding:12px;border-radius:12px;border:1px solid rgba(57,255,106,.35);background:rgba(0,0,0,.35);color:var(--text);font:inherit" />`;
    const ok = await openModal("SET USERNAME", html, { okText:"SAVE", cancelText:"CANCEL" });
    if (!ok) return;

    const v = ($("nameInput")?.value || "").trim().replace(/\s+/g," ");
    state.username = v || "Operator";
    touchUpdated();
    saveLocal();
    saveCloud(true);
    popupComms("OPS", `Alright, ${state.username}. Callsign confirmed.`);
  }

  // ===== Controls
  const pingBtn = $("ping");
  const briefingBtn = $("briefing");
  const saveBtn = $("save");
  const wipeBtn = $("wipe");
  const prestigeBtn = $("prestige");
  const userChip = $("userChip");

  if (pingBtn){
    pingBtn.onclick = () => {
      markActive();
      gain(state.clickPower * globalMult());
      state.corruption = clamp(state.corruption + 0.0006, 0, 1);

      touchUpdated();
      renderHUD();
      renderUpgrades();
      renderDecoder();

      saveLocal();
      saveCloud(false);

      if (state.total < 40) popupComms("OPS", `Ping it a few times, ${state.username}. Then buy Dish Calibration.`);
    };
  }

  if (briefingBtn){
    briefingBtn.onclick = () => {
      markActive();
      openModal(
        "HOME BASE COMMUNIQUE",
        `<div style="white-space:pre-wrap">
<b>SYGN1L BRIEFING</b>

Operator ${escapeHtml(state.username)}:
Ping the Void to generate Signal.
Spend Signal on Buffs to increase Signal/sec and Bandwidth.
As phases unlock, the Array begins to answer.

When the Decoder unlocks in Phase V, each Engram reveals more of an intercepted warning.
If it says to reset, do it. The Array forgets. You don’t.
</div>`,
        { okText:"ACKNOWLEDGED", cancelText:"CLOSE" }
      );
    };
  }

  if (saveBtn){
    saveBtn.onclick = () => {
      markActive();
      saveLocal();
      saveCloud(true);
      pushLog("log","SYS","STATE SAVED.");
    };
  }

  if (wipeBtn){
    wipeBtn.onclick = async () => {
      markActive();
      const ok = await confirmAction("WIPE", "This will delete LOCAL and CLOUD saves.\n\nAre you sure?", "WIPE");
      if (!ok) return;

      localStorage.removeItem(LOCAL_KEYS[0]);
      // Optional: remove legacy keys too
      for (const k of LOCAL_KEYS.slice(1)) localStorage.removeItem(k);

      if (supabase && cloudReady && userId){
        try{ await supabase.from("saves").delete().eq("player_id", userId); } catch(_){}
      }
      location.reload();
    };
  }

  if (prestigeBtn){
    prestigeBtn.onclick = async () => {
      markActive();
      const g = prestigeGain();
      const ok = await confirmAction("RITE RESET", `You will reset this build for +${g} relics.\nDecoder progress persists.\n\nProceed?`, "RITE RESET");
      if (!ok) return;

      doRiteReset();
      touchUpdated();
      saveLocal();
      saveCloud(true);

      renderHUD();
      renderUpgrades();
      renderDecoder();
    };
  }

  if (userChip){
    userChip.onclick = () => {
      markActive();
      editUsername();
    };
  }

  // ===== Upgrade refresh timer
  let upgradesRefreshAcc = 0;
  const UPGRADES_REFRESH_EVERY = 0.25;

  // ===== Main loop
  function tick(dt){
    recompute();
    const rate = sps();
    if (rate > 0) gain(rate * dt);

    if (state.autoPingsPerSec > 0){
      const p = state.autoPingsPerSec * dt;
      gain(p * (state.clickPower * globalMult()));
    }

    updateCorruption(dt);
    phaseCheck();
  }

  // ===== Boot render
  function renderUpfront(){
    recompute();
    renderHUD();
    renderUpgrades();
    renderDecoder();
  }

  // ===== Start loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.05, (now-last)/1000);
    last = now;

    tick(dt);

    upgradesRefreshAcc += dt;
    if (upgradesRefreshAcc >= UPGRADES_REFRESH_EVERY){
      upgradesRefreshAcc = 0;
      renderUpgrades();
      renderDecoder();
    }

    drawScope(dt);
    renderHUD();

    state.lastTickMs = Date.now();
    requestAnimationFrame(loop);
  }

  // ===== Start
  resizeScope();
  renderUpfront();

  initSaves().then(() => {
    applyOfflineProgress();
    renderUpfront();
    pushLog("log","SYS","SAVE SYSTEM ONLINE: LOCAL + CLOUD (WHEN AVAILABLE).");
  }).finally(() => {
    renderUpfront();
    requestAnimationFrame(loop);
  });

})();

</body>
</html>