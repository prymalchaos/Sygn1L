 <!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport"
  content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"/>

<title>SYGN1L</title>

<style>
:root{
  --bg0:#020402; --bg1:#010701;
  --text:#CFFFD6; --muted:#7EDB92;
  --accent:#39FF6A; --danger:#FF3B6B;
  --border:rgba(57,255,106,.25);
  --radius:16px;
  --shadow:0 10px 22px rgba(0,0,0,.55);
  --glow:0 0 18px rgba(57,255,106,.25);
}

html{background:var(--bg0);}
body{
  margin:0;
  font-family:ui-monospace,Menlo,Consolas,monospace;
  color:var(--text);
  background:
    radial-gradient(900px 600px at 60% 15%, rgba(57,255,106,.10), transparent 60%),
    linear-gradient(180deg,var(--bg1),var(--bg0));
  padding:14px 12px calc(24px + env(safe-area-inset-bottom));
  -webkit-overflow-scrolling:touch;
}

.fx{
  position:fixed; inset:0;
  pointer-events:none;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(57,255,106,.05),
      rgba(57,255,106,.05) 1px,
      transparent 4px,
      transparent 8px
    );
  opacity:.22;
}

.wrap{max-width:860px;margin:0 auto;display:grid;gap:18px;}

.card{
  border:1px solid var(--border);
  border-radius:var(--radius);
  background:linear-gradient(180deg, rgba(6,28,12,.65), rgba(3,14,7,.45));
  box-shadow:var(--shadow);
  overflow:hidden;
}

.pad{padding:14px;}

h1{margin:0;font-size:18px;letter-spacing:.3em;}
.subtitle{font-size:12px;color:var(--muted);margin-top:6px;}

.stats{display:grid;grid-template-columns:1fr;gap:10px;margin-top:12px;}
@media(min-width:420px){.stats{grid-template-columns:repeat(3,1fr);}}

.stat{
  border:1px solid rgba(57,255,106,.25);
  border-radius:12px;
  padding:10px;
  background:rgba(0,0,0,.3);
}
.stat .k{font-size:11px;letter-spacing:.1em;color:var(--muted);}
.stat .v{font-size:18px;margin-top:6px;}

.hd{
  display:flex;flex-wrap:wrap;gap:8px;
  padding:12px 14px;
  border-bottom:1px solid rgba(57,255,106,.2);
  background:linear-gradient(180deg, rgba(0,0,0,.3), transparent);
}

.chip{
  border:1px solid rgba(57,255,106,.25);
  border-radius:999px;
  padding:6px 10px;
  font-size:10px;
  letter-spacing:.14em;
  background:rgba(0,0,0,.25);
  display:inline-flex;gap:8px;align-items:center;
}
.dot{width:8px;height:8px;border-radius:50%;background:var(--accent);box-shadow:var(--glow);}

button{
  font:inherit;
  border-radius:14px;
  border:1px solid rgba(57,255,106,.35);
  background:rgba(57,255,106,.08);
  color:var(--text);
  padding:14px;
  cursor:pointer;
  user-select:none;
}
button.big{
  width:100%;
  font-size:18px;
  font-weight:900;
  letter-spacing:.14em;
  padding:18px;
}

.grid2{display:grid;gap:10px;margin-top:12px;}
@media(min-width:420px){.grid2{grid-template-columns:1fr 1fr;}}

.upgrades{display:flex;flex-direction:column;gap:12px;}
.up{
  border:1px dashed rgba(57,255,106,.25);
  border-radius:14px;
  padding:12px;
  background:rgba(0,0,0,.35);
  display:flex;justify-content:space-between;align-items:center;
}

.scopeWrap{
  margin-top:10px;
  border:1px solid rgba(57,255,106,.22);
  border-radius:12px;
  overflow:hidden;
  background:rgba(0,0,0,.35);
}
.scopeTop{
  padding:8px 10px;
  font-size:10px;
  letter-spacing:.12em;
  border-bottom:1px solid rgba(57,255,106,.15);
}
canvas{display:block;width:100%;height:84px;}

.log{
  max-height:300px;
  overflow:auto;
  -webkit-overflow-scrolling:touch;
}
.log p{font-size:12px;line-height:1.55;margin:0 0 10px;}

.tag{
  border:1px solid rgba(57,255,106,.25);
  border-radius:999px;
  padding:2px 8px;
  font-size:10px;
  letter-spacing:.1em;
  margin-right:6px;
}

/* ===== Modal ===== */
.modalHost{
  position:fixed; inset:0;
  display:none;
  z-index:2000;
  padding:14px;
  background:rgba(0,0,0,.75);
  overflow:auto;
}

.modal{
  max-width:860px;
  margin:0 auto;
  max-height:calc(100dvh - 28px);
  display:flex;
  flex-direction:column;
  border:1px solid rgba(57,255,106,.35);
  border-radius:18px;
  background:linear-gradient(180deg, rgba(6,28,12,.9), rgba(3,14,7,.85));
}

.modal .mhd{
  padding:12px;
  font-size:12px;
  letter-spacing:.14em;
  border-bottom:1px solid rgba(57,255,106,.2);
}

.modal .mbody{
  padding:14px;
  overflow:auto;
  font-size:12px;
  line-height:1.55;
  flex:1 1 auto;
}

.modal .mfoot{
  padding:12px;
  border-top:1px solid rgba(57,255,106,.2);
  display:flex;gap:10px;
}

</style>
</head>

<body>
<div class="fx"></div>

<div class="modalHost" id="modalHost">
  <div class="modal">
    <div class="mhd" id="modalTitle">TRANSMISSION</div>
    <div class="mbody" id="modalBody"></div>
    <div class="mfoot">
      <button id="modalOk">ACKNOWLEDGED</button>
      <button id="modalCancel">CLOSE</button>
    </div>
  </div>
</div>

<div class="wrap">

<header class="card">
  <div class="pad">
    <h1>SYGN1L</h1>
    <div class="subtitle">THE ARRAY LISTENS.</div>

    <div class="stats">
      <div class="stat"><div class="k">SIGNAL</div><div class="v" id="signal">0</div></div>
      <div class="stat"><div class="k">SIGNAL/SEC</div><div class="v" id="sps">0</div></div>
      <div class="stat"><div class="k">BANDWIDTH</div><div class="v" id="bw">1.00×</div></div>
    </div>

    <div class="scopeWrap">
      <div class="scopeTop">ARRAY SCOPE</div>
      <canvas id="scope"></canvas>
    </div>
    
    <div class="stat">
  <div class="k">CORRUPTION</div>
  <div class="bar"><div class="fill danger" id="corrFill"></div></div>
  <div class="muted" id="corrText">0% (DORMANT)</div>
</div>
  </div>
  

  
  
</header>

<section class="card">
  <div class="hd">
    <span class="chip"><span class="dot"></span><span id="phase">PHASE I</span></span>
    <span class="chip" id="userChip">USER: ----</span>
    <span class="chip" id="liveChip">LIVE: ACTIVE</span>
  </div>

  <div class="pad">
    <button class="big" id="ping">PING THE VOID</button>

    <div class="grid2">
      <button id="briefing">BRIEFING</button>
      <button id="save">SAVE</button>
    </div>

    <div class="grid2">
      <button id="wipe">WIPE</button>
      <button id="prestige">RITE RESET</button>
    </div>
  </div>
  
  
  
</section>

<section class="card">
  <div class="hd">
    <div>BUFFS</div>
    <div class="chip">AVAILABLE BUFFS GLOW</div>
  </div>
  <div class="pad">
    <div class="upgrades" id="upgrades">
      <!-- populated by JS -->
    </div>
  </div>
</section>


<section class="card">
  <div class="hd"><div>COMMUNICATIONS</div></div>
  <div class="pad">
    <div class="log" id="comms"></div>
  </div>
</section>

<section class="card">
  <div class="hd"><div>XENO DECODER</div></div>
  <div class="pad" id="decoder">
    <div class="subtitle">STATUS: ENCRYPTED</div>
  </div>
</section>


</div>

  <!-- Supabase (ENABLED) -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  // Prevent double-tap zoom on buttons (mobile)
  document.addEventListener("dblclick", (e) => {
    if (e.target && e.target.closest("button")) e.preventDefault();
  }, { passive:false });

  document.documentElement.style.touchAction = "manipulation";
  document.body.style.touchAction = "manipulation";

  // ===== Supabase config (yours)
  const SUPABASE_URL = "https://qwrvlhdouicfyypxjffn.supabase.co";
  const SUPABASE_ANON_KEY = "sb_publishable_uBQsnY94g__2VzSm4Z9Yvg_mq32-ABR";
  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  // ===== Utils
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  function fmt(n){
    n = Number(n);
    if (!Number.isFinite(n)) return "0";
    if (n < 1000) return n.toFixed(0);
    const u=["K","M","B","T","Qa","Qi"];
    let i=-1;
    while(n>=1000 && i<u.length-1){ n/=1000; i++; }
    return n.toFixed(n<10?2:n<100?1:0)+u[i];
  }
  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  // ===== Modal system (scrollable)
  const modalHost = $("modalHost");
  const modalTitle = $("modalTitle");
  const modalBody  = $("modalBody");
  const modalOk    = $("modalOk");
  const modalCancel= $("modalCancel");

  function openModal(title, html, opts={}){
    modalTitle.textContent = title || "TRANSMISSION";
    modalBody.innerHTML = html || "";
    modalOk.textContent = opts.okText || "ACKNOWLEDGED";
    modalCancel.textContent = opts.cancelText || "CLOSE";
    modalCancel.style.display = opts.hideCancel ? "none" : "";
    modalHost.style.display = "block";
    requestAnimationFrame(() => { modalBody.scrollTop = 0; });

    return new Promise((resolve) => {
      const onOk = () => cleanup(true);
      const onCancel = () => cleanup(false);

      function cleanup(v){
        modalOk.removeEventListener("click", onOk);
        modalCancel.removeEventListener("click", onCancel);
        modalHost.removeEventListener("click", onBack);
        modalHost.style.display = "none";
        resolve(v);
      }
      function onBack(e){
        if (e.target === modalHost) cleanup(false);
      }
      modalOk.addEventListener("click", onOk);
      modalCancel.addEventListener("click", onCancel);
      modalHost.addEventListener("click", onBack);
    });
  }

  async function confirmAction(title, message, okText){
    const html = `<div style="white-space:pre-wrap">${escapeHtml(message)}</div>`;
    return await openModal(title, html, { okText: okText || "CONFIRM", cancelText:"CANCEL" });
  }

  // ===== Comms log (tap-to-dismiss)
  function pushComms(who, msg){
    const p = document.createElement("p");
    p.innerHTML = `<span class="tag">${escapeHtml(who)}</span>${escapeHtml(msg)}`;
    p.style.cursor = "pointer";
    p.title = "Tap to dismiss";
    p.addEventListener("click", () => p.remove());
    $("comms").prepend(p);
  }

  // ===== State
  const DEFAULT_ARCHIVE = () => ({
    phase5Unlocked: false,
    engramsSolved: 0,
    engramsTotal: 0,
    hasCipherKey: false,
    awaitingRiteReset: false,
    finalMessageRevealed: false,
    scrambleSeed: (Math.floor(Math.random()*1e9) >>> 0)
  });

  const state = {
    username: "Operator",
    build: 1,
    relics: 0,

    signal: 0,
    total: 0,

    baseSPS: 0,
    clickPower: 1,
    bandwidth: 1.0,
    autoPingsPerSec: 0,

    corruption: 0,
    phase: 1,

    updatedAtMs: Date.now(),
    lastTickMs: Date.now(),
    lastUserActionAt: 0,

    archive: DEFAULT_ARCHIVE(),

    upgrades: {
      dish: 0, scan: 0, probes: 0, tuning: 0,
      autopinger: 0, echo: 0, lattice: 0, dark: 0,
      purifier: 0, firewall: 0, deadband: 0, decoderRig: 0,
      relicAmp: 0
    }
  };
  window.SYGN1L = state;

  // ===== Activity gating
  function markActive(){ state.lastUserActionAt = Date.now(); }
  window.addEventListener("pointerdown", markActive, { passive:true });
  window.addEventListener("keydown", markActive, { passive:true });
  const isActivelyUsed = () => (Date.now() - state.lastUserActionAt) <= 20000;

  // ===== Local save migration
  const LOCAL_KEY = "sygn1l_save_v6";
  const LEGACY_KEYS = [
    "sygn1l_cloudsave_v3","sygn1l_cloudsave_v2","sygn1l_cloudsave_v1",
    "sygn1l_save_v5","sygn1l_save_v4","sygn1l_save_v3","sygn1l_save_v2","sygn1l_save_v1"
  ];

  function mergeIntoState(data){
    if (!data || typeof data !== "object") return;

    const arch = (data.archive && typeof data.archive === "object") ? data.archive : null;
    data.archive = Object.assign(DEFAULT_ARCHIVE(), arch || {});
    data.upgrades = Object.assign({}, state.upgrades, data.upgrades || {});

    for (const k in data){
      if (data[k] && typeof data[k] === "object" && state[k] && typeof state[k] === "object"){
        Object.assign(state[k], data[k]);
      } else {
        state[k] = data[k];
      }
    }
  }

  function tryParseState(raw){
    try{
      const data = JSON.parse(raw);
      const t = Number(data.updatedAtMs || data.lastTickMs || 0);
      return { data, t: Number.isFinite(t) ? t : 0 };
    } catch { return null; }
  }

  function saveLocal(){
    state.updatedAtMs = Date.now();
    localStorage.setItem(LOCAL_KEY, JSON.stringify(state));
  }

  function loadLocal(){
    const keys = [LOCAL_KEY, ...LEGACY_KEYS];
    let best = null;

    for (const k of keys){
      const raw = localStorage.getItem(k);
      if (!raw) continue;
      const parsed = tryParseState(raw);
      if (!parsed) continue;
      if (!best || parsed.t > best.t) best = { key:k, data:parsed.data, t:parsed.t };
    }
    if (!best) return false;

    mergeIntoState(best.data);
    if (best.key !== LOCAL_KEY){
      saveLocal();
      pushComms("SYS", `LOCAL SAVE MIGRATED (${best.key} → ${LOCAL_KEY})`);
    } else {
      pushComms("SYS", "LOCAL SAVE LOADED.");
    }
    return true;
  }

  // ===== Supabase saves (cloud)
  let userId = null;
  let cloudReady = false;
  let lastCloudSaveAt = 0;

  async function ensureSession(){
    try{
      let { data: { session } } = await supabase.auth.getSession();
      if (!session){
        const { data, error } = await supabase.auth.signInAnonymously();
        if (error) throw error;
        session = data.session;
      }
      userId = session.user.id;
      cloudReady = true;
      return userId;
    } catch {
      cloudReady = false;
      return null;
    }
  }

  async function loadCloud(){
    if (!cloudReady || !userId) return null;
    try{
      const { data, error } = await supabase
        .from("saves")
        .select("state, updated_at")
        .eq("player_id", userId)
        .maybeSingle();
      if (error) throw error;
      if (!data || !data.state) return null;

      const cloudState = data.state;
      const cloudUpdatedMs = cloudState.updatedAtMs || (data.updated_at ? Date.parse(data.updated_at) : 0);
      return { cloudState, cloudUpdatedMs };
    } catch {
      cloudReady = false;
      return null;
    }
  }

  async function saveCloud(force=false){
    if (!cloudReady || !userId) return false;

    const now = Date.now();
    if (!force && (now - lastCloudSaveAt) < 45000) return false;
    lastCloudSaveAt = now;

    try{
      state.updatedAtMs = Date.now();
      const payload = {
        player_id: userId,
        updated_at: new Date().toISOString(),
        state: JSON.parse(JSON.stringify(state))
      };
      const { error } = await supabase.from("saves").upsert(payload);
      if (error) throw error;
      return true;
    } catch {
      cloudReady = false;
      return false;
    }
  }

  // ===== Derived math
  const lv = (id)=>state.upgrades[id]||0;
  const cost = (u)=>Math.floor(u.baseCost * Math.pow(u.costMult, lv(u.id)));

  function computeBaseSPS(){ return lv("dish")*1.0 + lv("tuning")*0.35; }
  function computeClickPower(){ return 1 + lv("probes")*1.0; }
  function computeBaseBandwidth(){
    let bw = 1.0;
    bw *= Math.pow(1.10, lv("scan"));
    bw *= Math.pow(1.01, lv("tuning"));
    bw *= (1 + 0.05 * lv("deadband"));
    return bw;
  }
  function computeEchoMultiplier(){
    const e = lv("echo");
    return e<=0 ? 1 : (1 + 0.03*e*Math.log10(state.signal+1));
  }
  function computeRelicMultiplier(){ return 1 + 0.08*(state.upgrades.relicAmp||0); }
  function computeLatticeMultiplier(){
    const l = lv("lattice");
    if (l<=0) return 1;
    const term = Math.sqrt(clamp(state.corruption,0,1)*10);
    return 1 + 0.06*l*term;
  }
  function computeDarkMultiplier(){
    const d = lv("dark");
    return d<=0 ? 1 : (state.corruption > 0.30 ? (1 + 0.12*d) : 1);
  }
  function computeAutoPingsPerSec(){
    const a = lv("autopinger");
    if (a<=0) return 0;
    const probeFactor = 1 + lv("probes")*0.15;
    return a * 0.65 * probeFactor;
  }

  function recompute(){
    state.baseSPS = computeBaseSPS();
    state.clickPower = computeClickPower();
    state.bandwidth = computeBaseBandwidth() * computeEchoMultiplier() * computeRelicMultiplier();
    state.autoPingsPerSec = computeAutoPingsPerSec();
  }
  const sps = ()=> state.baseSPS * state.bandwidth * computeLatticeMultiplier() * computeDarkMultiplier();
  const globalMult = ()=> state.bandwidth * computeLatticeMultiplier() * computeDarkMultiplier();

  // ===== Corruption
  function updateCorruption(dt){
    const creep = 0.0000025 * Math.log10(state.total + 10);
    const tech  = (lv("echo")*0.0000015) + (lv("lattice")*0.0000018) + (lv("dark")*0.0000022);
    const invite= 0.0000010;

    const firewall = 1 - clamp(0.06*lv("firewall"), 0, 0.55);
    const deadband = 1 + clamp(0.05*lv("deadband"), 0, 0.60);
    const phaseAmp = (state.phase >= 4) ? 1.35 : 1.0;

    state.corruption = clamp(state.corruption + (creep+tech+invite) * firewall * deadband * phaseAmp * dt, 0, 1);

    const pur = lv("purifier");
    if (pur > 0){
      state.corruption = clamp(state.corruption - (0.000010 * pur) * dt, 0, 1);
    }
  }

  // ===== Upgrades list
  const UPG = [
    { id:"dish", name:"DISH CALIBRATION", unlockAt:0, baseCost:10, costMult:1.18,
      desc:"+1 SIGNAL/SEC PER LEVEL.", buy(){ state.upgrades.dish++; } },

    { id:"scan", name:"DEEP SCAN", unlockAt:100, baseCost:50, costMult:1.25,
      desc:"+10% BASE BANDWIDTH PER LEVEL.", buy(){ state.upgrades.scan++; } },

    { id:"probes", name:"PROBE SWARM", unlockAt:120, baseCost:80, costMult:1.22,
      desc:"+1 CLICK POWER PER LEVEL.", buy(){ state.upgrades.probes++; } },

    { id:"tuning", name:"HARMONIC TUNING", unlockAt:240, baseCost:140, costMult:1.27,
      desc:"+0.35 SPS +1% BANDWIDTH PER LEVEL.", buy(){ state.upgrades.tuning++; } },

    { id:"autopinger", name:"AUTO-PINGER ROUTINE", unlockAt:600, baseCost:520, costMult:1.30,
      desc:"ADDS AUTO-PINGS/SEC. SCALES WITH PROBES.", buy(){ state.upgrades.autopinger++; } },

    { id:"echo", name:"ECHO INTEGRATOR", unlockAt:1800, baseCost:1400, costMult:1.35,
      desc:"BANDWIDTH BONUS SCALES WITH LOG(SIGNAL).", buy(){ state.upgrades.echo++; } },

    { id:"lattice", name:"HARMONIC LATTICE", unlockAt:3500, baseCost:3200, costMult:1.38,
      desc:"SPS MULT SCALES WITH CORRUPTION.", buy(){ state.upgrades.lattice++; } },

    { id:"dark", name:"DARK LISTENING", unlockAt:7000, baseCost:9000, costMult:1.45,
      desc:"IF CORRUPTION>30%: GAINS × (1 + 0.12*LV).", buy(){ state.upgrades.dark++; } },

    { id:"firewall", name:"FIREWALL SIGIL", unlockAt:9000, baseCost:8500, costMult:1.42,
      desc:"SLOWS CORRUPTION GROWTH PER LEVEL.", buy(){ state.upgrades.firewall++; } },

    { id:"purifier", name:"SIGNAL PURIFIER", unlockAt:11000, baseCost:12000, costMult:1.48,
      desc:"PASSIVELY REDUCES CORRUPTION OVER TIME.", buy(){ state.upgrades.purifier++; } },

    { id:"deadband", name:"DEADBAND AMPLIFIER", unlockAt:13000, baseCost:16000, costMult:1.52,
      desc:"+BANDWIDTH BUT ADDS CORRUPTION PRESSURE.", buy(){ state.upgrades.deadband++; } },

    { id:"decoderRig", name:"DECODER RIG", unlockAt:15000, baseCost:24000, costMult:1.60,
      desc:"REDUCES ENGRAM COSTS BY 6% PER LEVEL.", buy(){ state.upgrades.decoderRig++; } },
  ];

  // ===== Phases
  const PHASE2 = 500, PHASE3 = 1800, PHASE4 = 9000, PHASE5 = 15000;
  function setPhase(p){
    state.phase = Math.max(state.phase, p);
    $("phase").textContent = p===1?"PHASE I":p===2?"PHASE II":p===3?"PHASE III":p===4?"PHASE IV":"PHASE V";
  }
  function phaseCheck(){
    if (state.total >= PHASE2) setPhase(2);
    if (state.total >= PHASE3) setPhase(3);
    if (state.total >= PHASE4) setPhase(4);
    if (state.total >= PHASE5) setPhase(5);
  }

  // ===== Decoder
  const FINAL_MESSAGE = "Greetings! This is a warning. Prepare for invasion. They are coming";
  function initDecoderIfNeeded(){
    if (!state.archive || typeof state.archive !== "object") state.archive = DEFAULT_ARCHIVE();
    if (!state.archive.engramsTotal || state.archive.engramsTotal <= 0){
      state.archive.engramsTotal = FINAL_MESSAGE.length;
      state.archive.engramsSolved = clamp(state.archive.engramsSolved, 0, state.archive.engramsTotal);
    }
  }
  function engramCost(){
    const n = state.archive.engramsSolved;
    const rigDiscount = Math.pow(0.94, lv("decoderRig"));
    const base = 1200;
    const ramp = Math.pow(1.14, n);
    return Math.floor(base * ramp * rigDiscount);
  }
  function scrambleDisplay(seed, revealedCount){
    const text = FINAL_MESSAGE;
    const len = text.length;
    let s = (seed >>> 0) || 1;
    const rnd = () => {
      s ^= s << 13; s >>>= 0;
      s ^= s >>> 17; s >>>= 0;
      s ^= s << 5;  s >>>= 0;
      return (s >>> 0) / 4294967296;
    };

    const idx = [...Array(len).keys()];
    for (let i = len - 1; i > 0; i--){
      const j = Math.floor(rnd() * (i+1));
      [idx[i], idx[j]] = [idx[j], idx[i]];
    }
    const revealedPos = new Set(idx.slice(0, revealedCount));
    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!?.,:;-' ";
    const out = [];
    for (let i=0;i<len;i++){
      if (revealedPos.has(i)) out.push(text[i]);
      else out.push(alphabet[Math.floor(rnd()*alphabet.length)]);
    }
    return out.join("");
  }

  function renderDecoder(){
    const root = $("decoder");
    initDecoderIfNeeded();

    if (state.phase < 5){
      root.innerHTML = `<div class="subtitle">STATUS: LOCKED</div>
      <div style="margin-top:10px;color:var(--muted);font-size:12px;line-height:1.5">
        Reach PHASE V (15,000 total signal) to unlock the decoder.
      </div>`;
      return;
    }

    const solved = state.archive.engramsSolved;
    const total = state.archive.engramsTotal;
    const done = solved >= total;

    const scrambled = scrambleDisplay(state.archive.scrambleSeed, solved);
    const price = engramCost();
    const canBuy = state.signal >= price && !done;

    root.innerHTML = `
      <div class="subtitle">STATUS: ${done ? "CIPHER KEY ACQUIRED" : "DECRYPTING"}</div>

      <div style="margin-top:10px;border:1px solid rgba(57,255,106,.25);border-radius:12px;padding:10px;background:rgba(0,0,0,.30)">
        <div style="font-size:10px;letter-spacing:.12em;color:var(--muted);margin-bottom:6px">INTERCEPTED STRING</div>
        <div style="white-space:pre-wrap;word-break:break-word;font-size:12px;line-height:1.55">
          ${escapeHtml(scrambled)}
        </div>
      </div>

      <div style="margin-top:10px;font-size:12px;color:var(--muted)">
        ENGRAMS: <b style="color:var(--text)">${solved}</b> / ${total}
      </div>

      <div style="margin-top:12px;display:grid;gap:10px;grid-template-columns:1fr">
        <button id="decryptBtn" ${canBuy ? "" : "disabled"}>
          ${done ? "DECRYPT COMPLETE" : (canBuy ? `DECRYPT ENGRAM (COST ${fmt(price)})` : `INSUFFICIENT SIGNAL (COST ${fmt(price)})`)}
        </button>
      </div>
    `;

    const btn = $("decryptBtn");
    if (btn){
      btn.addEventListener("click", async () => {
        markActive();
        initDecoderIfNeeded();

        // recompute at click-time (no stale affordability)
        const priceNow = engramCost();
        if (state.signal < priceNow) return;

        state.signal -= priceNow;
        state.archive.engramsSolved++;

        if (state.archive.engramsSolved >= state.archive.engramsTotal){
          state.archive.engramsSolved = state.archive.engramsTotal;
          state.archive.hasCipherKey = true;
          state.archive.awaitingRiteReset = true;
          pushComms("DR KESS", `${state.username}, final engram is a key. We need a Rite Reset to apply it.`);
        }

        saveLocal(); await saveCloud(false);
        renderHUD(); renderUpgrades(); renderDecoder();
      });
    }
  }

  // ===== Rite Reset / Wipe
  function prestigeGain(){
    const over = Math.max(0, state.total - 12000);
    return 1 + Math.floor(Math.sqrt(over / 6000));
  }

  function doRiteReset(){
    const keepArchive = JSON.parse(JSON.stringify(state.archive || DEFAULT_ARCHIVE()));
    const keepUsername = state.username;

    state.relics += prestigeGain();
    state.build += 1;

    state.signal = 0;
    state.total = 0;
    state.corruption = Math.max(0, state.corruption * 0.25);
    state.phase = 1;

    for (const k in state.upgrades) state.upgrades[k] = 0;

    state.archive = keepArchive;
    state.username = keepUsername;

    if (state.archive.awaitingRiteReset && state.archive.hasCipherKey && !state.archive.finalMessageRevealed){
      state.archive.awaitingRiteReset = false;
      state.archive.finalMessageRevealed = true;
      pushComms("DECRYPT", FINAL_MESSAGE);
      pushComms("OPS", `…We have a clean decode, ${state.username}. That’s not a drill.`);
    }
  }

  // ===== Briefing
  async function showBriefing(){
    const html = `
<div style="white-space:pre-wrap">
<b>HOME BASE COMMUNIQUE</b>

${escapeHtml(`Operator ${state.username}:

Ping the Void to generate Signal.
Spend Signal on Buffs to increase Signal/second and Bandwidth.
As Signal accumulates, phases unlock and the Array begins to answer.

Early steps:
1) Buy DISH CALIBRATION (starts Signal/second).
2) Reach 100 total Signal to unlock DEEP SCAN.
3) Push toward PHASE V to unlock the decoder.

Corruption is pressure: it can empower upgrades, but it also destabilizes the Array.

Proceed.`)}
</div>`;
    await openModal("BRIEFING", html, { okText:"ACKNOWLEDGED", cancelText:"CLOSE" });
  }

  // ===== Username editing
  async function editUsername(){
    const html = `
<div style="font-size:12px;line-height:1.55;color:rgba(207,255,214,.92)">
  <div style="margin-bottom:10px;color:var(--muted)">Set a callsign. Used in comms.</div>
  <input id="nameInput" maxlength="18"
    value="${escapeHtml(state.username === "Operator" ? "" : state.username)}"
    placeholder="e.g. Corey"
    style="width:100%;box-sizing:border-box;padding:12px;border-radius:12px;border:1px solid rgba(57,255,106,.35);background:rgba(0,0,0,.35);color:var(--text);font:inherit"/>
</div>`;
    const ok = await openModal("SET USERNAME", html, { okText:"SAVE", cancelText:"CANCEL" });
    if (!ok) return;
    const el = $("nameInput");
    let v = (el?.value || "").trim().replace(/\s+/g," ");
    if (!v) v = "Operator";
    state.username = v;
    renderHUD();
    saveLocal(); await saveCloud(true);
    pushComms("OPS", `Alright, ${state.username}. Callsign confirmed.`);
  }

  // ===== Casual human chatter every 4–6 mins (active only)
  let nextChatterAt = Date.now() + 120000;
  const CHATTER = [
    (n)=>`Hey ${n}. Quick check in. You alright?`,
    (n)=>`If you need a breather, take it. The Array isn’t going anywhere.`,
    (n)=>`Okay, that spike was not normal. You saw it too, right ${n}?`,
    (n)=>`Not gonna lie, ${n}, I hate how it “feels” when the scope locks in.`,
    (n)=>`Coffee update: it’s awful. Signal update: how’s yours, ${n}?`,
    (n)=>`${n}, reminder: dishes first. Everything else starts behaving after that.`,
    (n)=>`We’re all pretending this is science. It’s… not. Keep going, ${n}.`,
    (n)=>`I’m here if you want to pause. But also… don’t stop now, ${n}.`,
  ];
  const SPEAKERS = ["OPS","TECH RIV","DR KESS","LT VANCE"];

  function maybeChatter(){
    const now = Date.now();
    if (document.visibilityState !== "visible") return;
    if (!isActivelyUsed()) return;
    if (now < nextChatterAt) return;

    const who = SPEAKERS[Math.floor(Math.random()*SPEAKERS.length)];
    const line = CHATTER[Math.floor(Math.random()*CHATTER.length)](state.username || "Operator");
    pushComms(who, line);

    nextChatterAt = now + (240000 + Math.floor(Math.random()*120000));
  }

  // ===== Offline progress
  function applyOfflineProgress(){
    const now = Date.now();
    const then = state.lastTickMs || state.updatedAtMs || now;
    const dtMs = clamp(now - then, 0, 1000*60*60*12);
    const dt = dtMs / 1000;
    if (dt < 10) return;

    recompute();
    const rate = sps();

    const cap = 60*20 + (state.phase*60*10) + (lv("purifier")*60*10);
    const effective = Math.min(dt, cap);

    const gained = rate * effective;
    state.signal += gained;
    state.total += gained;

    updateCorruption(effective * 0.6);

    pushComms("SYS", `OFFLINE RECOVERY: +${fmt(gained)} SIGNAL (${Math.floor(effective)}s simulated)`);
  }

  // ===== UI render
  function renderHUD(){
  $("signal").textContent = fmt(state.signal);
  $("sps").textContent = fmt(sps());
  $("bw").textContent = state.bandwidth.toFixed(2) + "×";
  $("userChip").textContent = `USER: ${state.username}`;

  const live = $("liveChip");
  if (live){
    live.textContent = isActivelyUsed() ? "LIVE: ACTIVE" : "LIVE: IDLE";
    live.style.opacity = isActivelyUsed() ? "1" : "0.65";
  }

  // ✅ Corruption bar + label (only if elements exist)
  const cf = $("corrFill");
  const ct = $("corrText");
  if (cf) cf.style.width = (state.corruption * 100).toFixed(1) + "%";
  if (ct) ct.textContent =
    (state.corruption * 100).toFixed(1) + "% (" + corruptionLabel(state.corruption) + ")";
}

  // ===== IMPORTANT FIX: renderUpgrades recomputes affordability fresh each time
  function renderUpgrades(){
    const root = $("upgrades");
    root.innerHTML = "";

    for (const u of UPG){
      const unlocked = state.total >= u.unlockAt;
      const lvlNow = lv(u.id);
      const price = cost(u);
      const affordable = unlocked && state.signal >= price;

      const row = document.createElement("div");
      row.className = "up";
      row.style.borderStyle = unlocked ? "solid" : "dashed";
      row.style.opacity = unlocked ? "1" : "0.65";
      if (affordable) row.style.boxShadow = "0 0 18px rgba(57,255,106,.18)";

      const left = document.createElement("div");
      left.style.flex = "1";
      left.style.minWidth = "220px";
      left.innerHTML = `
        <div style="font-weight:900;letter-spacing:.04em">${escapeHtml(u.name)} (LV ${lvlNow})</div>
        <div style="margin-top:6px;font-size:12px;color:var(--muted)">
          ${escapeHtml(unlocked ? u.desc : `LOCKED UNTIL ${fmt(u.unlockAt)} TOTAL SIGNAL.`)}
        </div>
        <div style="margin-top:6px;font-size:12px;color:rgba(207,255,214,.92)">
          ${unlocked ? `COST: ${fmt(price)} SIGNAL` : `STATUS: LOCKED`}
        </div>
      `;

      const btn = document.createElement("button");
      btn.textContent = unlocked ? (affordable ? "ACQUIRE" : "LOCKED") : "CLASSIFIED";
      btn.disabled = !affordable;
      btn.style.padding = "12px 14px";

      // Click handler RECOMPUTES affordability at click time (no stale closure)
      btn.addEventListener("click", async () => {
        markActive();

        const unlockedNow = state.total >= u.unlockAt;
        const priceNow = cost(u);
        const affordableNow = unlockedNow && state.signal >= priceNow;

        if (!affordableNow) return;

        state.signal -= priceNow;
        u.buy();

        saveLocal();
        await saveCloud(false);

        renderHUD();
        renderUpgrades();
        renderDecoder();
      });

      row.appendChild(left);
      row.appendChild(btn);
      root.appendChild(row);
    }
  }

  // ===== Scope visualizer
  const scope = $("scope");
  const ctx = scope.getContext("2d", { alpha:false });
  let dpr = 1, sw = 0, sh = 0;
  let t = 0;

  function resizeScope(){
    dpr = Math.max(1, Math.min(3, window.devicePixelRatio||1));
    const cssW = scope.clientWidth || 320;
    const cssH = 84;
    scope.width = Math.floor(cssW * dpr);
    scope.height = Math.floor(cssH * dpr);
    sw = scope.width; sh = scope.height;
  }
  window.addEventListener("resize", resizeScope);

  function drawScope(dt){
    if (!sw || !sh) return;
    t += dt;

    const lock = clamp((Math.log10(state.total+1)/5) * (1 - 0.55*state.corruption), 0, 1);

    ctx.fillStyle = "rgb(0,0,0)";
    ctx.fillRect(0,0,sw,sh);

    const noiseAmt = clamp(0.75 - 0.55*lock + 0.25*state.corruption, 0.15, 0.9);
    const px = Math.max(1, Math.floor(dpr));

    for (let y=0;y<sh;y+=px){
      for (let x=0;x<sw;x+=px){
        const n = Math.random();
        if (n < noiseAmt){
          const g = Math.floor(120 + 130*n);
          ctx.fillStyle = `rgb(0,${g},0)`;
          ctx.fillRect(x,y,px,px);
        }
      }
    }

    const mid = Math.floor(sh*0.60);
    ctx.strokeStyle = "rgba(57,255,106,0.85)";
    ctx.lineWidth = Math.max(1, 1*dpr);
    ctx.beginPath();
    for (let i=0;i<120;i++){
      const x = (i/119)*(sw-1);
      const spike = (Math.random() < (0.05 + 0.35*lock)) ? (0.2 + 0.8*Math.random()) : 0;
      const wave  = Math.sin(t*2 + i*0.12) * (0.08 + 0.12*(1-lock));
      const corr  = state.corruption > 0.45 ? Math.sin(t*8+i*0.2)*(0.05+0.18*state.corruption) : 0;
      const y = mid - (spike + wave + corr) * (sh*0.70);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    if (state.phase >= 4){
      const tears = Math.floor(2 + 6*state.corruption);
      for (let i=0;i<tears;i++){
        const x = Math.floor(Math.random()*sw);
        ctx.fillStyle = `rgba(255,59,107,${0.03 + 0.10*state.corruption})`;
        ctx.fillRect(x, 0, Math.max(1, Math.floor(dpr)), sh);
      }
    }
  }
function corruptionLabel(c){
  if (c < 0.10) return "DORMANT";
  if (c < 0.30) return "WHISPERING";
  if (c < 0.60) return "INCIDENT";
  if (c < 0.85) return "BREACH";
  return "OVERRUN";
}
  // ===== Core loop
  function gain(x){
    state.signal += x;
    state.total += x;
  }

  function tick(dt){
    recompute();

    const rate = sps();
    if (rate > 0) gain(rate*dt);

    if (state.autoPingsPerSec > 0){
      const p = state.autoPingsPerSec * dt;
      gain(p * (state.clickPower * globalMult()));
    }

    updateCorruption(dt);
    phaseCheck();
    initDecoderIfNeeded();
    maybeChatter();
  }

  // ===== Controls
  $("ping").addEventListener("click", async () => {
    markActive();
    gain(state.clickPower * globalMult());
    state.corruption = clamp(state.corruption + 0.0006, 0, 1);
    saveLocal(); await saveCloud(false);
    renderHUD(); renderUpgrades(); renderDecoder();
  }, { passive:true });

  $("briefing").addEventListener("click", () => { markActive(); showBriefing(); }, { passive:true });
  $("save").addEventListener("click", async () => { markActive(); saveLocal(); await saveCloud(true); pushComms("SYS","STATE SAVED."); }, { passive:true });

  $("wipe").addEventListener("click", async () => {
    markActive();
    const ok = await confirmAction("WIPE", "This will delete LOCAL and CLOUD saves.\n\nAre you sure?", "WIPE");
    if (!ok) return;

    localStorage.removeItem(LOCAL_KEY);
    for (const k of LEGACY_KEYS) localStorage.removeItem(k);

    if (cloudReady && userId){
      try{ await supabase.from("saves").delete().eq("player_id", userId); }catch{}
    }
    location.reload();
  });

  $("prestige").addEventListener("click", async () => {
    markActive();
    const g = prestigeGain();
    const ok = await confirmAction("RITE RESET", `You will reset this build for +${g} relics.\nDecoder discoveries persist.\n\nProceed?`, "RITE RESET");
    if (!ok) return;

    doRiteReset();
    saveLocal(); await saveCloud(true);
    renderHUD(); renderUpgrades(); renderDecoder();
  });

  $("userChip").addEventListener("click", () => { markActive(); editUsername(); });

  // ===== Boot comms
  function bootComms(){
    if ($("comms").children.length === 0){
      pushComms("OPS", "Ping the Void so we can establish signal integrity.");
      pushComms("DR KESS", "We need you to calibrate the dishes. That’s how the snowball starts.");
      pushComms("TECH RIV", "If anything starts sounding like language… tell us. Immediately.");
    }
  }

  // ===== Init + loop
  async function init(){
    const hadLocal = loadLocal();
    await ensureSession();

    const cloud = await loadCloud();
    if (cloud?.cloudState){
      const localUpdated = Number(state.updatedAtMs || 0);
      if (cloud.cloudUpdatedMs > localUpdated){
        mergeIntoState(cloud.cloudState);
        pushComms("SYS", "CLOUD SAVE LOADED (NEWER THAN LOCAL).");
      } else if (cloudReady){
        await saveCloud(true);
      }
    }

    applyOfflineProgress();

    resizeScope();
    bootComms();

    renderHUD();
    renderUpgrades();
    renderDecoder();

    if (!hadLocal){
      pushComms("OPS", `Welcome aboard, ${state.username}. Start with DISH CALIBRATION.`);
    }

    saveLocal(); await saveCloud(true);
  }

  // ===== THE IMPORTANT FIX: periodic upgrades refresh while AFK
  let upgradesRefreshAcc = 0;
  const UPGRADES_REFRESH_EVERY = 0.25; // seconds

  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.05, (now-last)/1000);
    last = now;

    tick(dt);
    drawScope(dt);
    renderHUD();

    // periodic refresh so buttons unlock/relight while idling
    upgradesRefreshAcc += dt;
    if (upgradesRefreshAcc >= UPGRADES_REFRESH_EVERY){
      upgradesRefreshAcc = 0;
      renderUpgrades();
      renderDecoder();
    }

    if (Math.random() < 0.02){
      saveLocal();
      saveCloud(false);
    }

    state.lastTickMs = Date.now();
    requestAnimationFrame(loop);
  }

  document.addEventListener("visibilitychange", async () => {
    if (document.visibilityState === "hidden"){
      saveLocal(); await saveCloud(true);
    }
  });

  init().then(() => requestAnimationFrame(loop));

})();
</script>
</body>
</html>
